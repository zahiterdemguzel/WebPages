<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector OBJ Painting Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            /* Prevent body scroll */
        }

        canvas {
            touch-action: none;
            /* Disable default touch actions for custom pan/zoom */
        }
    </style>
</head>

<body class="flex flex-col h-screen bg-gray-200">

    <div class="bg-gray-700 text-white shadow-md py-2 px-4 flex items-center space-x-4">
        <button id="load-obj-button"
            class="flex items-center px-3 py-2 rounded-md hover:bg-gray-600 transition duration-200">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                </path>
            </svg>
            Load OBJ
        </button>
        <input id="load-obj-input" type="file" accept=".obj" class="hidden">

        <button id="open-project-button"
            class="flex items-center px-3 py-2 rounded-md hover:bg-gray-600 transition duration-200">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z">
                </path>
            </svg>
            Open Project
        </button>
        <input id="open-project-input" type="file" accept=".kufi" class="hidden">

        <button id="save-project-btn"
            class="flex items-center px-3 py-2 rounded-md hover:bg-gray-600 transition duration-200">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4">
                </path>
            </svg>
            Save Project
        </button>

        <button id="save-project-as-btn"
            class="flex items-center px-3 py-2 rounded-md hover:bg-gray-600 transition duration-200">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 13h6m-3-3v6m5 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                </path>
            </svg>
            Save Project As
        </button>

        <button id="export-svg-btn"
            class="flex items-center px-3 py-2 rounded-md hover:bg-gray-600 transition duration-200">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z">
                </path>
            </svg>
            Export SVG
        </button>

        <button id="export-png-btn"
            class="flex items-center px-3 py-2 rounded-md hover:bg-gray-600 transition duration-200">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z">
                </path>
            </svg>
            Export PNG
        </button>

        <button id="clear-canvas-btn"
            class="flex items-center px-3 py-2 rounded-md hover:bg-gray-600 transition duration-200">
            <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16">
                </path>
            </svg>
            Clear
        </button>
    </div>

    <div class="flex flex-1 overflow-hidden">
        <div class="w-48 bg-gray-800 text-white shadow-lg p-4 flex flex-col space-y-4">
            <div class="flex flex-col space-y-2">
                <button id="tool-paint"
                    class="flex flex-col items-center justify-center p-2 rounded-md transition duration-200 bg-blue-600 border-2 border-yellow-400">
                    <svg class="w-6 h-6 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                        xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2V5a2 2 0 00-2-2h-2.586a1 1 0 01-.707-.293l-5.414-5.414a1 1 0 00-.707-.293H7a2 2 0 00-2 2v12a4 4 0 014 4z">
                        </path>
                    </svg>
                    Paint
                </button>
                <button id="tool-erase"
                    class="flex flex-col items-center justify-center p-2 rounded-md transition duration-200 bg-gray-700 hover:bg-gray-600">
                    <svg class="w-6 h-6 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                        xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16">
                        </path>
                    </svg>
                    Erase
                </button>
                <button id="tool-move"
                    class="flex flex-col items-center justify-center p-2 rounded-md transition duration-200 bg-gray-700 hover:bg-gray-600">
                    <svg class="w-6 h-6 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                        xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M8 9l3 3m0 0l3-3m-3 3v4m0 1.5a.5.5 0 01-.5.5h-3a.5.5 0 01-.5-.5v-3a.5.5 0 01.5-.5h3a.5.5 0 01.5.5v3zM12 12a9 9 0 100 18 9 9 0 000-18z">
                        </path>
                    </svg>
                    Move
                </button>
            </div>

            <div class="h-px bg-gray-600 my-4"></div>
            <h3 class="text-sm font-bold text-gray-400 mb-2">Colors:</h3>
            <div class="grid grid-cols-2 gap-2" id="color-palette">
            </div>

            <div class="flex-grow"></div> <button id="undo-btn"
                class="flex flex-col items-center justify-center p-2 rounded-md bg-gray-700 hover:bg-gray-600 transition duration-200">
                <svg class="w-6 h-6 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M12 14l-4-4m0 0l4-4m-4 4h11a2 2 0 012 2v8a2 2 0 01-2 2H7a2 2 0 01-2-2V7a2 2 0 012-2h1">
                    </path>
                </svg>
                Undo
            </button>
            <button id="redo-btn"
                class="flex flex-col items-center justify-center p-2 rounded-md bg-gray-700 hover:bg-gray-600 transition duration-200">
                <svg class="w-6 h-6 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M12 10l4 4m0 0l-4 4m4-4H3a2 2 0 01-2-2V7a2 2 0 012-2h11a2 2 0 012 2v8a2 2 0 01-2 2H12z">
                    </path>
                </svg>
                Redo
            </button>
        </div>

        <div class="flex-1 p-4 flex items-center justify-center overflow-hidden">
            <canvas id="objCanvas" class="bg-white rounded-lg shadow-inner w-full h-full"></canvas>
        </div>
    </div>

    <div id="status-bar" class="bg-gray-700 text-white text-sm py-2 px-4 shadow-inner">
        Ready
    </div>

    <div id="modal-container"
        class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50">
        <div id="modal-content" class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full mx-4">
            <h2 id="modal-title" class="text-xl font-semibold mb-4 text-gray-800"></h2>
            <div id="modal-body" class="mb-6"></div>
            <div class="flex justify-end space-x-3">
                <button id="modal-cancel-btn"
                    class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition duration-200">
                    Cancel
                </button>
                <button id="modal-ok-btn"
                    class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition duration-200">
                    OK
                </button>
            </div>
        </div>
    </div>

    <div id="message-box-container"
        class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50">
        <div id="message-box-content" class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full mx-4">
            <div class="flex items-center mb-4">
                <div id="message-box-icon"></div>
                <h2 id="message-box-title" class="text-xl font-semibold ml-3 text-gray-800"></h2>
            </div>
            <p id="message-box-message" class="text-gray-700 mb-6 whitespace-pre-wrap"></p>
            <div id="message-box-checkbox-container" class="mb-4 hidden">
                <label class="flex items-center text-gray-700">
                    <input id="message-box-checkbox" type="checkbox"
                        class="form-checkbox h-5 w-5 text-blue-600 rounded">
                    <span id="message-box-checkbox-label" class="ml-2"></span>
                </label>
            </div>
            <div class="flex justify-end">
                <button id="message-box-ok-btn"
                    class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition duration-200">
                    OK
                </button>
                <button id="message-box-cancel-btn"
                    class="ml-3 px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition duration-200 hidden">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <script>
        // Helper for point operations
        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            add(other) {
                return new Point(this.x + other.x, this.y + other.y);
            }

            subtract(other) {
                return new Point(this.x - other.x, this.y - other.y);
            }

            scale(factor) {
                return new Point(this.x * factor, this.y * factor);
            }

            distanceTo(other) {
                return Math.hypot(this.x - other.x, this.y - other.y);
            }

            toIntegerPoint() {
                return new Point(Math.round(this.x), Math.round(this.y));
            }
        }

        // Helper for rectangle operations
        class Rect {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }

            get left() { return this.x; }
            get top() { return this.y; }
            get right() { return this.x + this.width; }
            get bottom() { return this.y + this.height; }

            get topLeft() { return new Point(this.x, this.y); }
            get topRight() { return new Point(this.x + this.width, this.y); }
            get bottomLeft() { return new Point(this.x, this.y + this.height); }
            get bottomRight() { return new Point(this.x + this.width, this.y + this.height); }

            contains(point) {
                return point.x >= this.x && point.x <= this.x + this.width &&
                    point.y >= this.y && point.y <= this.y + this.height;
            }

            normalized() {
                const x = Math.min(this.x, this.x + this.width);
                const y = Math.min(this.y, this.y + this.height);
                const width = Math.abs(this.width);
                const height = Math.abs(this.height);
                return new Rect(x, y, width, height);
            }
        }

        // Helper for 2D transformations (mimics QTransform)
        class Transform {
            constructor(m11 = 1, m12 = 0, m21 = 0, m22 = 1, dx = 0, dy = 0) {
                this.m11 = m11; // scaleX
                this.m12 = m12; // skewY
                this.m21 = m21; // skewX
                this.m22 = m22; // scaleY
                this.dx = dx;    // translateX
                this.dy = dy;    // translateY
            }

            map(point) {
                if (point instanceof Point) {
                    const x = this.m11 * point.x + this.m21 * point.y + this.dx;
                    const y = this.m12 * point.x + this.m22 * point.y + this.dy;
                    return new Point(x, y);
                } else if (Array.isArray(point)) {
                    return point.map(p => this.map(p));
                }
                return point;
            }

            inverted() {
                const det = this.m11 * this.m22 - this.m12 * this.m21;
                if (det === 0) {
                    return [null, false];
                }
                const invDet = 1 / det;
                const invM11 = this.m22 * invDet;
                const invM12 = -this.m12 * invDet;
                const invM21 = -this.m21 * invDet;
                const invM22 = this.m11 * invDet;
                const invDx = -(this.dx * invM11 + this.dy * invM21);
                const invDy = -(this.dx * invM12 + this.dy * invM22);
                return [new Transform(invM11, invM12, invM21, invM22, invDx, invDy), true];
            }

            times(other) {
                const newM11 = this.m11 * other.m11 + this.m21 * other.m12;
                const newM12 = this.m12 * other.m11 + this.m22 * other.m12;
                const newM21 = this.m11 * other.m21 + this.m21 * other.m22;
                const newM22 = this.m12 * other.m21 + this.m22 * other.m22;
                const newDx = this.m11 * other.dx + this.m21 * other.dy + this.dx;
                const newDy = this.m12 * other.dx + this.m22 * other.dy + this.dy;
                return new Transform(newM11, newM12, newM21, newM22, newDx, newDy);
            }

            scale(sx, sy) {
                return this.times(new Transform(sx, 0, 0, sy, 0, 0));
            }

            translate(tx, ty) {
                return this.times(new Transform(1, 0, 0, 1, tx, ty));
            }
        }

        // KDTree implementation
        class KDTreeNode {
            constructor(point, index, left, right, axis) {
                this.point = point; // Point object {x, y}
                this.index = index; // corresponding face index
                this.left = left;
                this.right = right;
                this.axis = axis; // splitting axis (0 for x, 1 for y)
            }
        }

        function buildKDTree(items, depth = 0) {
            if (!items || items.length === 0) {
                return null;
            }
            const axis = depth % 2; // 0 for x, 1 for y
            items.sort((a, b) => (axis === 0 ? a[0].x - b[0].x : a[0].y - b[0].y));
            const median = Math.floor(items.length / 2);
            return new KDTreeNode(
                items[median][0],
                items[median][1],
                buildKDTree(items.slice(0, median), depth + 1),
                buildKDTree(items.slice(median + 1), depth + 1),
                axis
            );
        }

        function kdTreeQuery(node, point, best = null) {
            if (node === null) {
                return best;
            }

            const axis = node.axis;
            const distSq = node.point.distanceTo(point) ** 2;

            if (best === null || distSq < best[0]) {
                best = [distSq, node.point, node.index];
            }

            const diff = (axis === 0 ? point.x : point.y) - (axis === 0 ? node.point.x : node.point.y);
            const [close, away] = diff < 0 ? [node.left, node.right] : [node.right, node.left];

            best = kdTreeQuery(close, point, best);

            if (diff ** 2 < best[0]) {
                best = kdTreeQuery(away, point, best);
            }
            return best;
        }

        class KDTree {
            constructor(items) {
                this.root = buildKDTree(items);
            }

            query(point) {
                const result = kdTreeQuery(this.root, point);
                return result; // [dist_sq, point, index]
            }
        }

        // Point in Polygon check (ray casting algorithm)
        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;

                const intersect = ((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // --- Custom Modal and Message Box Implementations ---
        const modalContainer = document.getElementById('modal-container');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');
        const modalOkBtn = document.getElementById('modal-ok-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        let modalResolve;

        function showModal(title, contentHtml, showCancel = true) {
            return new Promise(resolve => {
                modalTitle.textContent = title;
                modalBody.innerHTML = contentHtml;
                modalCancelBtn.classList.toggle('hidden', !showCancel);
                modalContainer.classList.remove('hidden');

                const handleOk = () => {
                    modalContainer.classList.add('hidden');
                    modalOkBtn.removeEventListener('click', handleOk);
                    modalCancelBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };

                const handleCancel = () => {
                    modalContainer.classList.add('hidden');
                    modalOkBtn.removeEventListener('click', handleOk);
                    modalCancelBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };

                modalOkBtn.addEventListener('click', handleOk);
                modalCancelBtn.addEventListener('click', handleCancel);
                modalResolve = resolve; // Store resolve for external use if needed
            });
        }

        const messageBoxContainer = document.getElementById('message-box-container');
        const messageBoxIcon = document.getElementById('message-box-icon');
        const messageBoxTitle = document.getElementById('message-box-title');
        const messageBoxMessage = document.getElementById('message-box-message');
        const messageBoxCheckboxContainer = document.getElementById('message-box-checkbox-container');
        const messageBoxCheckbox = document.getElementById('message-box-checkbox');
        const messageBoxCheckboxLabel = document.getElementById('message-box-checkbox-label');
        const messageBoxOkBtn = document.getElementById('message-box-ok-btn');
        const messageBoxCancelBtn = document.getElementById('message-box-cancel-btn');

        let messageBoxResolve;

        function showMessageBox(title, message, type = 'info', showCancel = false, showCheckbox = false, checkboxLabel = '') {
            return new Promise(resolve => {
                messageBoxTitle.textContent = title;
                messageBoxMessage.textContent = message;
                messageBoxCheckboxContainer.classList.toggle('hidden', !showCheckbox);
                messageBoxCheckbox.checked = false; // Reset checkbox state
                messageBoxCheckboxLabel.textContent = checkboxLabel;
                messageBoxCancelBtn.classList.toggle('hidden', !showCancel);
                messageBoxContainer.classList.remove('hidden');

                const iconMap = {
                    info: `<svg class="w-8 h-8 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`,
                    warning: `<svg class="w-8 h-8 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.302 16c-.77 1.333.192 3 1.732 3z"></path></svg>`,
                    error: `<svg class="w-8 h-8 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`,
                    question: `<svg class="w-8 h-8 text-purple-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9.247a4.75 4.75 0 015.657 0M15 12a3 3 0 11-6 0 3 3 0 016 0zm-7.5 3h1.5m4.5 0h1.5m-7.5 3h1.5m4.5 0h1.5M12 21a9 9 0 110-18 9 9 0 010 18z"></path></svg>`,
                };
                messageBoxIcon.innerHTML = iconMap[type] || '';

                const handleOk = () => {
                    messageBoxContainer.classList.add('hidden');
                    messageBoxOkBtn.removeEventListener('click', handleOk);
                    messageBoxCancelBtn.removeEventListener('click', handleCancel);
                    resolve({ confirmed: true, checkboxChecked: messageBoxCheckbox.checked });
                };

                const handleCancel = () => {
                    messageBoxContainer.classList.add('hidden');
                    messageBoxOkBtn.removeEventListener('click', handleOk);
                    messageBoxCancelBtn.removeEventListener('click', handleCancel);
                    resolve({ confirmed: false, checkboxChecked: messageBoxCheckbox.checked });
                };

                messageBoxOkBtn.addEventListener('click', handleOk);
                messageBoxCancelBtn.addEventListener('click', handleCancel);
                messageBoxResolve = resolve;
            });
        }

        // --- Custom Save Dialog ---
        function showSaveDialog(title, defaultFilename, extension) {
            return new Promise(resolve => {
                const inputId = 'save-filename-input';
                const contentHtml = `
                    <div class="space-y-4">
                        <div>
                            <label for="${inputId}" class="block text-gray-700 text-sm font-bold mb-2">Filename:</label>
                            <input id="${inputId}" type="text" value="${defaultFilename}"
                                class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                        </div>
                    </div>
                `;
                showModal(title, contentHtml, true).then(confirmed => {
                    if (confirmed) {
                        let filename = document.getElementById(inputId).value.trim();
                        if (filename) {
                            // Ensure the correct extension is present
                            if (!filename.endsWith(extension)) {
                                filename += extension;
                            }
                            resolve(filename);
                        } else {
                            // If filename is empty after trim, consider it cancelled or invalid
                            showMessageBox("Invalid Filename", "Filename cannot be empty.", 'warning');
                            resolve(null); // Or prompt again, depending on desired strictness
                        }
                    } else {
                        resolve(null); // User cancelled
                    }
                });
            });
        }

        // --- Global State ---
        let vertices = [];
        let faces = [];
        let faceColors = {}; // {faceIndex: "rgba(r,g,b,a)"}
        let selectedFaces = new Set();

        let movePoints = null; // {faceIndex: {color: "rgba", pos: Point}}
        let selectedPoints = new Set();

        let currentTool = 'paint';
        let fillColor = 'rgba(255, 104, 104, 1)';

        let isPainting = false;
        let activePaintTool = null; // 'paint' or 'erase'
        let strokeInProgress = false;

        let isSelecting = false;
        let selectStart = null; // Point
        let selectRect = null; // Rect
        let selectModifiers = 0; // 0: none, 1: Ctrl/Cmd

        let isMovingSelection = false;
        let moveStartPos = null; // Point
        let moveDelta = new Point(0, 0); // Point
        let moveOriginalState = {}; // For points: {key: originalPoint}, for faces: {face: color}
        let moveOriginalSelected = new Set(); // Keys/faces that were selected at start of move

        let isRotatingSelection = false;
        let rotateStartPos = null; // Point
        let rotateCurrentPos = null; // Point
        let rotateOriginalState = {}; // For points: {key: originalPoint}, for faces: {face: color}
        let rotateOriginalSelected = new Set(); // Keys/faces that were selected at start of rotate

        let zoom = 1.0;
        let panOffset = new Point(0, 0); // panOffset is in screen pixels
        let middleMouseDown = false;
        let isPanningCanvas = false; // New state variable for left-click canvas pan
        let lastPanPoint = null;

        let undoStack = [];
        let redoStack = [];
        const maxUndoStackSize = 30;

        let faceCenters = []; // Array of Point
        let cachedFacePolygons = []; // Array of arrays of Points
        let cachedFacePaths = []; // Array of Path2D objects
        let kdTree = null;

        let currentFilePath = null;
        let isModified = false;

        let exportResolution = { width: 3500, height: 3500 };

        // --- DOM Elements ---
        const canvas = document.getElementById('objCanvas');
        const ctx = canvas.getContext('2d');
        const statusBar = document.getElementById('status-bar');

        const loadObjButton = document.getElementById('load-obj-button'); // Get the button
        const loadObjInput = document.getElementById('load-obj-input');
        const openProjectButton = document.getElementById('open-project-button'); // Get the button
        const openProjectInput = document.getElementById('open-project-input');
        const saveProjectBtn = document.getElementById('save-project-btn');
        const saveProjectAsBtn = document.getElementById('save-project-as-btn');
        const exportSvgBtn = document.getElementById('export-svg-btn');
        const exportPngBtn = document.getElementById('export-png-btn');
        const clearCanvasBtn = document.getElementById('clear-canvas-btn');

        const toolPaintBtn = document.getElementById('tool-paint');
        const toolEraseBtn = document.getElementById('tool-erase');
        const toolMoveBtn = document.getElementById('tool-move');
        const colorPalette = document.getElementById('color-palette');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');

        // --- Performance Optimization: Request Animation Frame for drawing ---
        let needsRedraw = false;

        function requestRedraw() {
            if (!needsRedraw) {
                needsRedraw = true;
                requestAnimationFrame(animate);
            }
        }

        function animate() {
            if (needsRedraw) {
                draw();
                needsRedraw = false;
            }
        }

        // --- Functions ---

        function updateTitle() {
            const baseTitle = "Vector OBJ Painting Editor";
            let title = baseTitle;
            if (currentFilePath) {
                const filename = currentFilePath.split('/').pop().split('\\').pop();
                title = `${baseTitle} - ${filename}`;
            }
            if (isModified) {
                title += " *";
            }
            document.title = title;
        }

        function onProjectModified() {
            if (!isModified) {
                isModified = true;
                updateTitle();
            }
        }

        function loadObjFileContent(fileContent) {
            const verts = [];
            const fcs = [];
            const lines = fileContent.split('\n');
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine || trimmedLine.startsWith('#')) {
                    continue;
                }
                const parts = trimmedLine.split(/\s+/);
                if (parts[0] === 'v' && parts.length >= 4) {
                    try {
                        const x = parseFloat(parts[1]);
                        const y = parseFloat(parts[2]);
                        const z = parseFloat(parts[3]);
                        verts.push([x, y, z]);
                    } catch (e) {
                        console.error("Error parsing vertex:", e);
                        continue;
                    }
                } else if (parts[0] === 'f' && parts.length >= 3) {
                    const indices = [];
                    for (let i = 1; i < parts.length; i++) {
                        try {
                            const idx = parseInt(parts[i].split('/')[0]) - 1;
                            indices.push(idx);
                        } catch (e) {
                            console.error("Error parsing face index:", e);
                            continue;
                        }
                    }
                    if (indices.length >= 3) {
                        fcs.push(indices);
                    }
                }
            }

            if (verts.length === 0 || fcs.length === 0) {
                showMessageBox("Error", "Failed to load OBJ file or file is empty.", 'error');
                return;
            }

            vertices = verts;
            faces = fcs;
            faceColors = {};
            selectedFaces = new Set();
            movePoints = null;
            selectedPoints = new Set();
            undoStack = [];
            redoStack = [];
            zoom = 1.0;
            panOffset = new Point(0, 0);
            currentFilePath = null;
            isModified = true;
            computeFaceCenters();
            cacheFacePolygons();
            requestRedraw(); // Use requestRedraw
            updateTitle();
            statusBar.textContent = "OBJ Template loaded.";
            setTimeout(() => statusBar.textContent = "Ready", 3000);
        }

        function boundingBox() {
            if (vertices.length === 0) {
                return { min_x: 0, max_x: 0, min_z: 0, max_z: 0 };
            }
            let min_x = Infinity, max_x = -Infinity;
            let min_z = Infinity, max_z = -Infinity;
            for (const v of vertices) {
                min_x = Math.min(min_x, v[0]);
                max_x = Math.max(max_x, v[0]);
                min_z = Math.min(min_z, v[2]);
                max_z = Math.max(max_z, v[2]);
            }
            return { min_x, max_x, min_z, max_z };
        }

        function computeTransform() {
            if (!canvas || vertices.length === 0) {
                return new Transform();
            }
            const margin = 20;
            const w = canvas.width;
            const h = canvas.height;

            const { min_x, max_x, min_z, max_z } = boundingBox();
            const modelWidth = max_x - min_x;
            const modelHeight = max_z - min_z;

            let s = 1.0;
            if (modelWidth > 0 && modelHeight > 0) {
                s = Math.min((w - 2 * margin) / modelWidth, (h - 2 * margin) / modelHeight);
            }

            // Base transform to fit model into canvas with Y-axis flip
            const baseTransform = new Transform(s, 0, 0, -s, margin - s * min_x, margin + s * max_z);

            // User transform for pan and zoom (applied after base transform)
            const userTransform = new Transform()
                .scale(zoom, zoom)
                .translate(panOffset.x, panOffset.y);

            return userTransform.times(baseTransform);
        }

        function computeFaceCenters() {
            faceCenters = [];
            for (const face of faces) {
                let sumX = 0;
                let sumZ = 0;
                let count = 0;
                for (const idx of face) {
                    if (idx >= 0 && idx < vertices.length) {
                        const v = vertices[idx];
                        sumX += v[0];
                        sumZ += v[2];
                        count++;
                    }
                    else {
                        console.warn(`Invalid vertex index ${idx} in face. Skipping.`);
                    }
                }
                if (count > 0) {
                    faceCenters.push(new Point(sumX / count, sumZ / count));
                } else {
                    // If a face has no valid vertices, push a default point to maintain index alignment
                    faceCenters.push(new Point(0, 0));
                }
            }
            const items = faceCenters.map((p, i) => [p, i]);
            kdTree = new KDTree(items);
        }

        function cacheFacePolygons() {
            cachedFacePolygons = [];
            cachedFacePaths = [];
            for (const face of faces) {
                const poly = [];
                const path = new Path2D();
                let first = true;
                for (const idx of face) {
                    if (idx >= 0 && idx < vertices.length) {
                        const v = vertices[idx];
                        const p = new Point(v[0], v[2]);
                        poly.push(p);
                        if (first) {
                            path.moveTo(p.x, p.y);
                            first = false;
                        } else {
                            path.lineTo(p.x, p.y);
                        }
                    }
                }
                if (poly.length > 0) {
                    path.closePath();
                }
                cachedFacePolygons.push(poly);
                cachedFacePaths.push(path);
            }
        }

        function getFaceCenter(faceIndex) {
            if (faceIndex < 0 || faceIndex >= faceCenters.length) {
                return new Point(0, 0);
            }
            return faceCenters[faceIndex];
        }

        function findClosestFace(target) {
            if (kdTree) {
                const result = kdTree.query(target);
                return result ? result[2] : null;
            }
            let bestIndex = null;
            let bestDist = Infinity;
            for (let i = 0; i < faceCenters.length; i++) {
                const center = faceCenters[i];
                const d = center.distanceTo(target);
                if (d < bestDist) {
                    bestDist = d;
                    bestIndex = i;
                }
            }
            return bestIndex;
        }

        function switchTool(newTool) {
            // Update UI for tool buttons
            document.querySelectorAll('#tool-paint, #tool-erase, #tool-move').forEach(btn => {
                btn.classList.remove('bg-blue-600', 'border-yellow-400');
                btn.classList.add('bg-gray-700', 'hover:bg-gray-600', 'border-transparent');
            });
            document.getElementById(`tool-${newTool}`).classList.add('bg-blue-600', 'border-2', 'border-yellow-400');
            document.getElementById(`tool-${newTool}`).classList.remove('bg-gray-700', 'hover:bg-gray-600', 'border-transparent');


            if (newTool === "move" && currentTool !== "move") {
                const newMovePoints = {};
                if (Object.keys(faceColors).length > 0) {
                    for (const faceIdxStr in faceColors) {
                        const faceIdx = parseInt(faceIdxStr);
                        const pos = getFaceCenter(faceIdx);
                        newMovePoints[faceIdx] = {
                            color: faceColors[faceIdx],
                            pos: new Point(pos.x, pos.y),
                        };
                    }
                } else {
                    for (let i = 0; i < faces.length; i++) {
                        const pos = getFaceCenter(i);
                        newMovePoints[i] = {
                            color: 'rgba(255, 255, 255, 1)',
                            pos: new Point(pos.x, pos.y),
                        };
                    }
                }
                movePoints = newMovePoints;
                selectedPoints = new Set();
                faceColors = {};
            } else if (newTool !== "move" && currentTool === "move") {
                if (movePoints) {
                    const newFaceColors = {};
                    for (const keyStr in movePoints) {
                        const key = parseInt(keyStr);
                        const data = movePoints[key];
                        const newFace = findClosestFace(data.pos);
                        if (newFace !== null) {
                            newFaceColors[newFace] = data.color;
                        }
                    }
                    faceColors = newFaceColors;
                }
                movePoints = null;
                selectedPoints = new Set();
            }
            currentTool = newTool;
            requestRedraw(); // Use requestRedraw
        }

        function pointAt(pos) {
            if (!movePoints) return null;
            const T = computeTransform();
            const threshold = 10;
            for (const keyStr in movePoints) {
                const key = parseInt(keyStr);
                const data = movePoints[key];
                const pointWidget = T.map(data.pos);
                const dist = pointWidget.distanceTo(pos);
                if (dist < threshold) {
                    return key;
                }
            }
            return null;
        }

        function getSelectionBoundingRect() {
            const T = computeTransform();
            let points = [];
            if (currentTool === "move" && movePoints && selectedPoints.size > 0) {
                for (const key of selectedPoints) {
                    if (movePoints[key]) {
                        points.push(T.map(movePoints[key].pos));
                    }
                }
            } else if (selectedFaces.size > 0) {
                for (const faceIdx of selectedFaces) {
                    points.push(T.map(getFaceCenter(faceIdx)));
                }
            } else {
                return null;
            }

            if (points.length === 0) return null;

            const xs = points.map(p => p.x);
            const ys = points.map(p => p.y);
            const minX = Math.min(...xs);
            const minY = Math.min(...ys);
            const maxX = Math.max(...xs);
            const maxY = Math.max(...ys);
            return new Rect(minX, minY, maxX - minX, maxY - minY);
        }

        function pushUndoState() {
            const newState = {
                faceColors: { ...faceColors },
                selectedFaces: new Set(selectedFaces),
                movePoints: movePoints ? JSON.parse(JSON.stringify(movePoints)) : null,
                selectedPoints: new Set(selectedPoints),
            };
            undoStack.push(newState);
            if (undoStack.length > maxUndoStackSize) {
                undoStack.shift();
            }
            redoStack = []; // Clear redo stack on new action
        }

        function undo() {
            if (undoStack.length === 0) return;

            const lastState = undoStack.pop();
            redoStack.push({
                faceColors: { ...faceColors },
                selectedFaces: new Set(selectedFaces),
                movePoints: movePoints ? JSON.parse(JSON.stringify(movePoints)) : null,
                selectedPoints: new Set(selectedPoints),
            });

            faceColors = lastState.faceColors;
            selectedFaces = lastState.selectedFaces;
            movePoints = lastState.movePoints;
            selectedPoints = lastState.selectedPoints;
            onProjectModified();
            requestRedraw(); // Use requestRedraw
        }

        function redo() {
            if (redoStack.length === 0) return;

            const nextState = redoStack.pop();
            undoStack.push({
                faceColors: { ...faceColors },
                selectedFaces: new Set(selectedFaces),
                movePoints: movePoints ? JSON.parse(JSON.stringify(movePoints)) : null,
                selectedPoints: new Set(selectedPoints),
            });

            faceColors = nextState.faceColors;
            selectedFaces = nextState.selectedFaces;
            movePoints = nextState.movePoints;
            selectedPoints = nextState.selectedPoints;
            onProjectModified();
            requestRedraw(); // Use requestRedraw
        }

        function paintAt(pos, tool) {
            const T = computeTransform();
            const [invertedT, ok] = T.inverted();
            if (!ok) return;

            const modelPos = invertedT.map(pos);

            let foundFaceIndex = null;
            for (let i = cachedFacePolygons.length - 1; i >= 0; i--) {
                const poly = cachedFacePolygons[i];
                if (isPointInPolygon(modelPos, poly)) {
                    foundFaceIndex = i;
                    break;
                }
            }

            if (foundFaceIndex === null) {
                return;
            }

            if (tool === "paint") {
                if (faceColors[foundFaceIndex] !== fillColor) {
                    faceColors[foundFaceIndex] = fillColor;
                    onProjectModified();
                    requestRedraw(); // Use requestRedraw
                }
            } else if (tool === "erase") {
                if (faceColors.hasOwnProperty(foundFaceIndex)) {
                    delete faceColors[foundFaceIndex];
                    if (selectedFaces.has(foundFaceIndex)) {
                        selectedFaces.delete(foundFaceIndex);
                    }
                    onProjectModified();
                    requestRedraw(); // Use requestRedraw
                }
            }
        }

        function updateMovePreview() {
            if (!moveOriginalSelected || moveOriginalSelected.size === 0) return;

            const T = computeTransform();
            const [invT, ok] = T.inverted();
            if (!ok) return;

            if (movePoints) {
                const deltaModel = invT.map(moveDelta).subtract(invT.map(new Point(0, 0)));
                for (const key of moveOriginalSelected) {
                    const origPos = moveOriginalState[key];
                    if (origPos) {
                        movePoints[key].pos = origPos.add(deltaModel);
                    }
                }
                selectedPoints = new Set(moveOriginalSelected);
            } else {
                const newFaceColorsPreview = { ...moveOriginalState };
                const previewMapping = {};
                const previewSelected = new Set();

                let groupCenter = new Point(0, 0);
                let count = 0;
                for (const faceIdx of moveOriginalSelected) {
                    groupCenter = groupCenter.add(getFaceCenter(faceIdx));
                    count++;
                }
                if (count > 0) {
                    groupCenter = new Point(groupCenter.x / count, groupCenter.y / count);
                }

                const deltaX = moveDelta.x / zoom;
                const deltaY = moveDelta.y / zoom;
                const newGroupCenter = groupCenter.add(new Point(deltaX, deltaY));

                for (const faceIdx of moveOriginalSelected) {
                    const originalCenter = getFaceCenter(faceIdx);
                    const rel = originalCenter.subtract(groupCenter);
                    const desired = newGroupCenter.add(rel);
                    const newFace = findClosestFace(desired);

                    if (newFace !== null) {
                        previewMapping[newFace] = moveOriginalState[faceIdx];
                        previewSelected.add(newFace);
                    }
                }

                for (const faceIdx of moveOriginalSelected) {
                    delete newFaceColorsPreview[faceIdx];
                }
                Object.assign(newFaceColorsPreview, previewMapping);

                faceColors = newFaceColorsPreview; // Apply preview to actual faceColors
                selectedFaces = previewSelected; // Apply preview to actual selectedFaces
            }
            requestRedraw(); // Use requestRedraw
        }

        function commitMovePreview() {
            if (movePoints) {
                isMovingSelection = false;
                moveDelta = new Point(0, 0);
                moveOriginalState = {};
                moveOriginalSelected = new Set();
                onProjectModified();
            } else {
                isMovingSelection = false;
                moveDelta = new Point(0, 0);
                moveOriginalState = {}; // This was already applied by updateMovePreview
                moveOriginalSelected = new Set();
                // selectedFaces is already updated by updateMovePreview
                onProjectModified();
            }
            requestRedraw(); // Use requestRedraw
        }

        function updateRotatePreview() {
            if (!rotateOriginalSelected || rotateOriginalSelected.size === 0) return;

            const T = computeTransform();
            const [invT, ok] = T.inverted();
            if (!ok) return;

            let groupCenter = new Point(0, 0);
            let count = 0;

            if (movePoints) {
                for (const key of rotateOriginalSelected) {
                    groupCenter = groupCenter.add(movePoints[key].pos);
                    count++;
                }
            } else {
                for (const faceIdx of rotateOriginalSelected) {
                    groupCenter = groupCenter.add(getFaceCenter(faceIdx));
                    count++;
                }
            }

            if (count > 0) {
                groupCenter = new Point(groupCenter.x / count, groupCenter.y / count);
            } else {
                return;
            }

            const startModel = invT.map(rotateStartPos);
            const currentModel = invT.map(rotateCurrentPos);

            const vecStart = startModel.subtract(groupCenter);
            const vecCurrent = currentModel.subtract(groupCenter);

            const angleStart = Math.atan2(vecStart.y, vecStart.x);
            const angleCurrent = Math.atan2(vecCurrent.y, vecCurrent.x);
            const angleDelta = angleCurrent - angleStart;

            if (movePoints) {
                for (const key of rotateOriginalSelected) {
                    const orig = rotateOriginalState[key];
                    const rel = orig.subtract(groupCenter);
                    const cosA = Math.cos(angleDelta);
                    const sinA = Math.sin(angleDelta);
                    const rotated = new Point(
                        rel.x * cosA - rel.y * sinA,
                        rel.x * sinA + rel.y * cosA
                    );
                    movePoints[key].pos = groupCenter.add(rotated);
                }
                selectedPoints = new Set(rotateOriginalSelected);
            } else {
                const newFaceColorsPreview = { ...rotateOriginalState };
                const previewMapping = {};
                const previewSelected = new Set();

                for (const faceIdx of rotateOriginalSelected) {
                    const originalCenter = getFaceCenter(faceIdx);
                    const rel = originalCenter.subtract(groupCenter);
                    const cosA = Math.cos(angleDelta);
                    const sinA = Math.sin(angleDelta);
                    const rotated = new Point(
                        rel.x * cosA - rel.y * sinA,
                        rel.x * sinA + rel.y * cosA
                    );
                    const desired = groupCenter.add(rotated);
                    const newFace = findClosestFace(desired);

                    if (newFace !== null) {
                        previewMapping[newFace] = rotateOriginalState[faceIdx];
                        previewSelected.add(newFace);
                    }
                }

                for (const faceIdx of rotateOriginalSelected) {
                    delete newFaceColorsPreview[faceIdx];
                }
                Object.assign(newFaceColorsPreview, previewMapping);

                faceColors = newFaceColorsPreview;
                selectedFaces = previewSelected;
            }
            requestRedraw(); // Use requestRedraw
        }

        function commitRotatePreview() {
            if (movePoints) {
                isRotatingSelection = false;
                rotateStartPos = null;
                rotateCurrentPos = null;
                rotateOriginalState = {};
                rotateOriginalSelected = new Set();
                onProjectModified();
            } else {
                isRotatingSelection = false;
                rotateStartPos = null;
                rotateCurrentPos = null;
                rotateOriginalState = {};
                // selectedFaces is already updated by updateRotatePreview
                rotateOriginalSelected = new Set();
                onProjectModified();
            }
            requestRedraw(); // Use requestRedraw
        }

        // Unified event handler for mouse and touch start
        function handlePointerDown(event) {
            // Prevent default touch actions like scrolling/zooming
            if (event.type.startsWith('touch')) {
                event.preventDefault();
            }

            const clientX = event.clientX || event.touches[0].clientX;
            const clientY = event.clientY || event.touches[0].clientY;

            const rect = canvas.getBoundingClientRect();
            const pos = new Point(clientX - rect.left, clientY - rect.top);

            // Prioritize middle mouse button for pan (or two-finger touch for future pinch-zoom)
            if (event.button === 1 || (event.type === 'touchstart' && event.touches.length === 2)) {
                middleMouseDown = true;
                lastPanPoint = pos;
                canvas.style.cursor = 'grab';
                return;
            }

            // Tool actions (left click or right click for paint/erase)
            if (currentTool === 'paint' || currentTool === 'erase') {
                const effectiveTool = event.button === 0 || event.type === 'touchstart' ? currentTool : (currentTool === 'paint' ? 'erase' : 'paint');
                if (!strokeInProgress) {
                    pushUndoState();
                    strokeInProgress = true;
                }
                isPainting = true;
                activePaintTool = effectiveTool;
                paintAt(pos, effectiveTool);
                return;
            }

            if (currentTool === 'move') {
                const selectionRect = getSelectionBoundingRect();
                let clickedOnGizmo = false;
                if (selectionRect) {
                    const handleCenter = selectionRect.topRight;
                    const handleRadius = 15;
                    const distToHandle = handleCenter.distanceTo(pos);
                    if (distToHandle <= handleRadius) {
                        clickedOnGizmo = true;
                    }
                }

                if (clickedOnGizmo) {
                    pushUndoState();
                    isRotatingSelection = true;
                    rotateStartPos = pos;
                    rotateCurrentPos = pos;
                    if (movePoints) {
                        rotateOriginalState = Object.fromEntries(
                            Array.from(selectedPoints).map(key => [key, movePoints[key].pos])
                        );
                        rotateOriginalSelected = new Set(selectedPoints);
                    } else {
                        rotateOriginalState = { ...faceColors };
                        rotateOriginalSelected = new Set(selectedFaces);
                    }
                } else if (selectionRect && selectionRect.contains(pos)) {
                    pushUndoState();
                    isMovingSelection = true;
                    moveStartPos = pos;
                    moveDelta = new Point(0, 0);
                    if (movePoints) {
                        moveOriginalState = Object.fromEntries(
                            Array.from(selectedPoints).map(key => [key, movePoints[key].pos])
                        );
                        moveOriginalSelected = new Set(selectedPoints);
                    } else {
                        moveOriginalState = { ...faceColors };
                        moveOriginalSelected = new Set(selectedFaces);
                    }
                } else { // Start selection or pan canvas if no selection/gizmo clicked
                    isSelecting = true;
                    selectStart = pos;
                    selectRect = new Rect(pos.x, pos.y, 0, 0);
                    selectModifiers = (event.ctrlKey || event.metaKey) ? 1 : 0;
                    if (movePoints) {
                        if (!selectModifiers) {
                            selectedPoints = new Set();
                        }
                    } else {
                        if (!selectModifiers) {
                            selectedFaces = new Set();
                        }
                    }
                }
                requestRedraw(); // Use requestRedraw
                return;
            }

            // Default left-click/single-touch pan for canvas if no specific tool action is taken
            if (event.button === 0 || (event.type === 'touchstart' && event.touches.length === 1)) {
                isPanningCanvas = true;
                lastPanPoint = pos;
                canvas.style.cursor = 'grab';
                return;
            }
        }

        // Unified event handler for mouse and touch move
        function handlePointerMove(event) {
            // Prevent default touch actions like scrolling/zooming
            if (event.type.startsWith('touch')) {
                event.preventDefault();
            }

            const clientX = event.clientX || event.touches[0].clientX;
            const clientY = event.clientY || event.touches[0].clientY;

            const rect = canvas.getBoundingClientRect();
            const pos = new Point(clientX - rect.left, clientY - rect.top);

            if (middleMouseDown || isPanningCanvas) {
                const delta = pos.subtract(lastPanPoint);
                panOffset = panOffset.add(delta);
                lastPanPoint = pos;
                requestRedraw(); // Use requestRedraw
                return;
            }

            if (isPainting) {
                paintAt(pos, activePaintTool);
                return;
            }

            if (currentTool === 'move') {
                if (isRotatingSelection) {
                    rotateCurrentPos = pos;
                    updateRotatePreview();
                } else if (isMovingSelection) {
                    moveDelta = pos.subtract(moveStartPos);
                    updateMovePreview();
                } else if (isSelecting) {
                    selectRect = new Rect(selectStart.x, selectStart.y, pos.x - selectStart.x, pos.y - selectStart.y);
                    requestRedraw(); // Use requestRedraw
                }
                return;
            }
        }

        // Unified event handler for mouse and touch end/cancel
        function handlePointerUp(event) {
            // Check for touchcancel to ensure state is reset
            if (event.type === 'touchcancel') {
                isPainting = false;
                strokeInProgress = false;
                isSelecting = false;
                isMovingSelection = false;
                isRotatingSelection = false;
                middleMouseDown = false;
                isPanningCanvas = false;
                canvas.style.cursor = 'default';
                requestRedraw(); // Request redraw to clear any partial states
                return;
            }

            if (event.button === 1 || (event.type === 'touchend' && !event.touches.length && middleMouseDown)) { // Middle mouse button or end of 2-finger touch
                middleMouseDown = false;
                canvas.style.cursor = 'default';
            }

            if (isPanningCanvas) { // Left mouse button pan or single-touch pan
                isPanningCanvas = false;
                canvas.style.cursor = 'default';
            }

            if (currentTool === 'paint' || currentTool === 'erase') {
                if (isPainting && (event.button === 0 || event.button === 2 || event.type === 'touchend')) {
                    isPainting = false;
                    strokeInProgress = false;
                }
                return;
            }

            if (currentTool === 'move') {
                if (isRotatingSelection) {
                    commitRotatePreview();
                } else if (isMovingSelection) {
                    commitMovePreview();
                } else if (isSelecting) {
                    const normalizedRect = selectRect.normalized();
                    if (normalizedRect.width < 5 && normalizedRect.height < 5) { // Single click
                        if (movePoints) {
                            const clientX = event.clientX || event.changedTouches[0].clientX;
                            const clientY = event.clientY || event.changedTouches[0].clientY;
                            const rect = canvas.getBoundingClientRect();
                            const pos = new Point(clientX - rect.left, clientY - rect.top);
                            const pointKey = pointAt(pos);
                            if (pointKey !== null) {
                                if (selectModifiers) {
                                    if (selectedPoints.has(pointKey)) {
                                        selectedPoints.delete(pointKey);
                                    } else {
                                        selectedPoints.add(pointKey);
                                    }
                                } else {
                                    selectedPoints = new Set([pointKey]);
                                }
                            } else if (!selectModifiers) {
                                selectedPoints = new Set();
                            }
                        } else {
                            const T = computeTransform();
                            const [invT, ok] = T.inverted();
                            if (!ok) return;
                            const clientX = event.clientX || event.changedTouches[0].clientX;
                            const clientY = event.clientY || event.changedTouches[0].clientY;
                            const rect = canvas.getBoundingClientRect();
                            const modelPos = invT.map(new Point(clientX - rect.left, clientY - rect.top));

                            let clickedFace = null;
                            for (let i = cachedFacePolygons.length - 1; i >= 0; i--) {
                                const poly = cachedFacePolygons[i];
                                if (isPointInPolygon(modelPos, poly)) {
                                    clickedFace = i;
                                    break;
                                }
                            }

                            if (clickedFace !== null) {
                                if (selectModifiers) {
                                    if (selectedFaces.has(clickedFace)) {
                                        selectedFaces.delete(clickedFace);
                                    } else {
                                        selectedFaces.add(clickedFace);
                                    }
                                } else {
                                    selectedFaces = new Set([clickedFace]);
                                }
                            } else if (!selectModifiers) {
                                selectedFaces = new Set();
                            }
                        }
                    } else { // Marquee select
                        const T = computeTransform();
                        if (movePoints) {
                            const newSelected = selectModifiers ? new Set(selectedPoints) : new Set();
                            for (const keyStr in movePoints) {
                                const key = parseInt(keyStr);
                                const data = movePoints[key];
                                const ptWidget = T.map(data.pos);
                                if (normalizedRect.contains(ptWidget.toIntegerPoint())) {
                                    newSelected.add(key);
                                }
                            }
                            selectedPoints = newSelected;
                        } else {
                            const newSelected = selectModifiers ? new Set(selectedFaces) : new Set();
                            // Iterate over ALL faces to select them, not just painted ones
                            for (let i = 0; i < faces.length; i++) {
                                const centerModel = getFaceCenter(i);
                                const centerWidget = T.map(centerModel);
                                if (normalizedRect.contains(centerWidget.toIntegerPoint())) {
                                    newSelected.add(i);
                                }
                            }
                            selectedFaces = newSelected;
                        }
                    }
                    isSelecting = false;
                    selectRect = null;
                    selectStart = null;
                    selectModifiers = 0;
                    requestRedraw(); // Use requestRedraw
                }
                return;
            }
        }

        function handleWheel(event) {
            event.preventDefault(); // Prevent page scrolling

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Calculate mouse position in the current "viewport" coordinates (after base transform, before user pan/zoom)
            // screen_x = (model_x_after_base * zoom) + panOffset.x
            // screen_y = (model_y_after_base * zoom) + panOffset.y
            const modelX = (mouseX - panOffset.x) / zoom;
            const modelY = (mouseY - panOffset.y) / zoom;

            const factor = event.deltaY > 0 ? 0.9 : 1.1; // Adjust zoom speed here
            zoom *= factor;

            // Update panOffset to keep the model point under the mouse cursor
            panOffset.x = mouseX - (modelX * zoom);
            panOffset.y = mouseY - (modelY * zoom);

            requestRedraw(); // Use requestRedraw
        }

        function draw() {
            if (!canvas) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the entire canvas

            ctx.fillStyle = '#ECEFF1';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (vertices.length === 0 || faces.length === 0) {
                ctx.fillStyle = '#607D8B';
                ctx.font = '20px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("Load a 3D OBJ file to start...", canvas.width / 2, canvas.height / 2);
                return;
            }

            const T = computeTransform();
            ctx.save();
            ctx.transform(T.m11, T.m12, T.m21, T.m22, T.dx, T.dy);

            if (currentTool === 'move' && movePoints !== null) {
                for (let i = 0; i < faces.length; i++) {
                    const path = cachedFacePaths[i];
                    ctx.fillStyle = 'white';
                    ctx.fill(path);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1 / T.m11; // Changed to 1px fixed on screen (was 2)
                    ctx.stroke(path);
                }
                ctx.restore();

                for (const keyStr in movePoints) {
                    const key = parseInt(keyStr);
                    const data = movePoints[key];
                    const ptWidget = T.map(data.pos);
                    const radius = 5;
                    ctx.beginPath();
                    ctx.arc(ptWidget.x, ptWidget.y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = data.color;
                    ctx.fill();
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    if (selectedPoints.has(key)) {
                        ctx.strokeStyle = 'blue';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            } else {
                for (let i = 0; i < faces.length; i++) {
                    const path = cachedFacePaths[i];
                    ctx.fillStyle = faceColors[i] || 'white';
                    ctx.fill(path);
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 1 / T.m11; // Changed to 1px fixed on screen (was 2)
                    ctx.stroke(path);

                    if (selectedFaces.has(i)) {
                        ctx.strokeStyle = 'blue';
                        ctx.lineWidth = 0.5 / T.m11; // Changed to 0.5px fixed on screen (was 1)
                        ctx.setLineDash([5 / T.m11, 5 / T.m11]);
                        ctx.stroke(path);
                        ctx.setLineDash([]);
                    }
                }
                ctx.restore();
            }

            if (currentTool === 'move' && isSelecting && selectRect) {
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                const normalizedRect = selectRect.normalized();
                ctx.strokeRect(normalizedRect.x, normalizedRect.y, normalizedRect.width, normalizedRect.height);
                ctx.setLineDash([]);
            } else if (currentTool === 'move' && movePoints !== null && selectedPoints.size > 0) {
                const rect = getSelectionBoundingRect();
                if (rect) {
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                    ctx.setLineDash([]);

                    const handleCenter = rect.topRight;
                    const handleRadius = 15;
                    ctx.beginPath();
                    ctx.arc(handleCenter.x, handleCenter.y, handleRadius, 0, 2 * Math.PI);
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            } else if (selectedFaces.size > 0 && currentTool !== 'move') {
                const rect = getSelectionBoundingRect();
                if (rect) {
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                    ctx.setLineDash([]);
                }
            }
        }

        // --- File Operations ---
        // Event listener for the Load OBJ button to trigger the hidden input
        loadObjButton.addEventListener('click', () => {
            loadObjInput.click();
        });

        loadObjInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            if (isModified) {
                showMessageBox("Unsaved Changes", "There are unsaved changes. Do you want to save them now?", 'question', true)
                    .then(({ confirmed }) => {
                        if (confirmed) {
                            saveProject(true, () => { // Pass true to force save-as behavior for initial save
                                const reader = new FileReader();
                                reader.onload = (e) => loadObjFileContent(e.target.result);
                                reader.readAsText(file);
                            });
                        } else {
                            const reader = new FileReader();
                            reader.onload = (e) => loadObjFileContent(e.target.result);
                            reader.readAsText(file);
                        }
                    });
            } else {
                const reader = new FileReader();
                reader.onload = (e) => loadObjFileContent(e.target.result);
                reader.readAsText(file);
            }
            // Clear the input's value to allow loading the same file again if needed
            event.target.value = '';
        });

        // Event listener for the Open Project button to trigger the hidden input
        openProjectButton.addEventListener('click', () => {
            openProjectInput.click();
        });

        openProjectInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const loadFileContent = (fileToLoad) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        vertices = data.vertices || [];
                        faces = data.faces || [];
                        const loadedFaceColors = {};
                        for (const key in data.faceColors) {
                            loadedFaceColors[parseInt(key)] = data.faceColors[key];
                        }
                        faceColors = loadedFaceColors;
                        selectedFaces = new Set(data.selectedFaces || []);
                        zoom = data.zoom || 1.0;
                        const pan = data.panOffset || [0, 0];
                        panOffset = new Point(pan[0], pan[1]);
                        undoStack = [];
                        redoStack = [];
                        movePoints = null;
                        selectedPoints = new Set();
                        currentFilePath = fileToLoad.name;
                        isModified = false;
                        computeFaceCenters();
                        cacheFacePolygons();
                        requestRedraw(); // Use requestRedraw
                        updateTitle();
                        showMessageBox("Success", "Project loaded.", 'info');
                    } catch (error) {
                        showMessageBox("Error", `Failed to load project: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(fileToLoad);
            };

            if (isModified) {
                showMessageBox("Unsaved Changes", "There are unsaved changes. Do you want to save them now?", 'question', true)
                    .then(({ confirmed }) => {
                        if (confirmed) {
                            saveProject(true, () => loadFileContent(file)); // Pass true to force save-as behavior
                        } else {
                            loadFileContent(file);
                        }
                    });
            } else {
                loadFileContent(file);
            }
            // Clear the input's value to allow loading the same file again if needed
            event.target.value = '';
        });

        async function saveProject(forceSaveAs = false, callback = () => { }) {
            if (vertices.length === 0) {
                showMessageBox("No Project", "There is no project to save.", 'info');
                return;
            }

            let filename = currentFilePath;

            if (forceSaveAs || !currentFilePath) {
                const defaultName = currentFilePath ? currentFilePath.replace(/\.kufi$/, '') : 'untitled';
                const result = await showSaveDialog("Save Project As", defaultName, '.kufi');
                if (result) {
                    filename = result;
                    currentFilePath = filename; // Update currentFilePath for future saves
                } else {
                    showMessageBox("Save Cancelled", "Project save was cancelled.", 'info');
                    callback(); // Still call callback even if cancelled, if it's part of a larger flow
                    return;
                }
            }

            const projectData = {
                vertices: vertices,
                faces: faces,
                faceColors: faceColors,
                selectedFaces: Array.from(selectedFaces),
                zoom: zoom,
                panOffset: [panOffset.x, panOffset.y],
            };

            const dataStr = JSON.stringify(projectData);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            isModified = false;
            updateTitle();
            showMessageBox("Success", `Project saved as "${filename}".`, 'info');
            callback();
        }
        saveProjectBtn.addEventListener('click', () => saveProject());

        async function saveProjectAs() {
            await saveProject(true); // Force save-as behavior
        }
        saveProjectAsBtn.addEventListener('click', saveProjectAs);

        async function exportSVG() {
            if (vertices.length === 0) {
                showMessageBox("No Content", "There is no content to export.", 'info');
                return;
            }

            const defaultName = currentFilePath ? currentFilePath.replace(/\.kufi$/, '.svg') : 'exported.svg';
            const filename = await showSaveDialog("Export SVG As", defaultName, '.svg');

            if (!filename) {
                showMessageBox("Export Cancelled", "SVG export was cancelled.", 'info');
                return;
            }

            const { min_x, max_x, min_z, max_z } = boundingBox();
            const modelWidth = max_x - min_x;
            const modelHeight = max_z - min_z;

            const svg_width = canvas.width;
            const svg_height = canvas.height;

            let s = 1.0;
            const margin = 20;
            if (modelWidth > 0 && modelHeight > 0) {
                s = Math.min((svg_width - 2 * margin) / modelWidth, (svg_height - 2 * margin) / modelHeight);
            }

            let svgContent = `<?xml version="1.0" encoding="UTF-8" ?>\n`;
            svgContent += `<svg xmlns="http://www.w3.org/2000/svg" width="${svg_width}" height="${svg_height}" version="1.1">\n`;
            svgContent += `<rect width="100%" height="100%" fill="#ECEFF1"/>\n`;

            const baseTransform = new Transform(s, 0, 0, -s, margin - s * min_x, margin + s * max_z);
            const fullTransform = new Transform()
                .scale(zoom, zoom)
                .translate(panOffset.x, panOffset.y)
                .times(baseTransform);

            for (let i = 0; i < faces.length; i++) {
                const face = faces[i];
                if (!face || face.length === 0) continue;

                const points = [];
                for (const idx of face) {
                    if (idx >= 0 && idx < vertices.length) {
                        const v = vertices[idx];
                        const transformedPoint = fullTransform.map(new Point(v[0], v[2]));
                        points.push(`${transformedPoint.x},${transformedPoint.y}`);
                    }
                }
                if (points.length === 0) continue;

                const pointsStr = points.join(" ");
                const fill = faceColors[i] || 'white';
                svgContent += `<polygon points="${pointsStr}" fill="${fill}" stroke="black" stroke-width="0.5"/>\n`;
            }
            svgContent += `</svg>\n`;

            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessageBox("Success", `SVG successfully exported as "${filename}".`, 'info');
        }
        exportSvgBtn.addEventListener('click', exportSVG);

        async function handleExportPng() {
            if (vertices.length === 0) {
                showMessageBox("No Content", "There is no content to export.", 'info');
                return;
            }
            const confirmedResolution = await showModal("Export Resolution", `
                <div class="space-y-4">
                    <div>
                        <label for="export-width" class="block text-gray-700 text-sm font-bold mb-2">Width:</label>
                        <input id="export-width" type="number" min="100" max="10000" value="${exportResolution.width}"
                               class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                    <div>
                        <label for="export-height" class="block text-gray-700 text-sm font-bold mb-2">Height:</label>
                        <input id="export-height" type="number" min="100" max="10000" value="${exportResolution.height}"
                               class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                </div>
            `, true);

            if (confirmedResolution) {
                const widthInput = document.getElementById('export-width');
                const heightInput = document.getElementById('export-height');
                exportResolution.width = parseInt(widthInput.value);
                exportResolution.height = parseInt(heightInput.value);
                await confirmExportPng();
            } else {
                showMessageBox("Export Cancelled", "PNG export was cancelled.", 'info');
            }
        }
        exportPngBtn.addEventListener('click', handleExportPng);

        async function confirmExportPng() {
            const defaultName = currentFilePath ? currentFilePath.replace(/\.kufi$/, '.png') : 'exported.png';
            const filename = await showSaveDialog("Export PNG As", defaultName, '.png');

            if (!filename) {
                showMessageBox("Export Cancelled", "PNG export was cancelled.", 'info');
                return;
            }

            const { width: userWidth, height: userHeight } = exportResolution;

            const { min_x, max_x, min_z, max_z } = boundingBox();
            const modelWidth = max_x - min_x;
            const modelHeight = max_z - min_z;

            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = userWidth;
            exportCanvas.height = userHeight;
            const ctxExport = exportCanvas.getContext('2d');

            ctxExport.fillStyle = '#ECEFF1';
            ctxExport.fillRect(0, 0, userWidth, userHeight);

            let s = 1.0;
            const margin = 20;
            if (modelWidth > 0 && modelHeight > 0) {
                s = Math.min(
                    (userWidth - 2 * margin) / modelWidth,
                    (userHeight - 2 * margin) / modelHeight
                );
            }

            const center_model_x = (min_x + max_x) / 2;
            const center_model_z = (min_z + max_z) / 2;
            const tx = userWidth / 2 - s * center_model_x;
            const ty = userHeight / 2 + s * center_model_z;

            const exportTransform = new Transform(s, 0, 0, -s, tx, ty);

            ctxExport.save();
            ctxExport.transform(exportTransform.m11, exportTransform.m12, exportTransform.m21, exportTransform.m22, exportTransform.dx, exportTransform.dy);

            for (let i = 0; i < faces.length; i++) {
                const path = cachedFacePaths[i];
                ctxExport.fillStyle = faceColors[i] || 'white';
                ctxExport.fill(path);
                ctxExport.strokeStyle = 'black';
                ctxExport.lineWidth = 1 / exportTransform.m11; // Changed to 1px fixed on screen (was 2)
                ctxExport.stroke(path);

                if (selectedFaces.has(i)) {
                    ctxExport.strokeStyle = 'blue';
                    ctxExport.lineWidth = 0.5 / exportTransform.m11; // Changed to 0.5px fixed on screen (was 1)
                    ctxExport.setLineDash([5 / exportTransform.m11, 5 / exportTransform.m11]);
                    ctxExport.stroke(path);
                    ctxExport.setLineDash([]);
                }
            }
            ctxExport.restore();

            const dataURL = exportCanvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showMessageBox("Success", `PNG successfully exported as "${filename}".`, 'info');
        }

        function clearCanvas() {
            if (vertices.length === 0) {
                showMessageBox("No Content", "Canvas is already empty.", 'info');
                return;
            }
            showMessageBox("Clear Canvas", "Do you want to clear all painted faces?", 'question', true)
                .then(({ confirmed }) => {
                    if (confirmed) {
                        pushUndoState();
                        faceColors = {};
                        selectedFaces = new Set();
                        movePoints = null;
                        selectedPoints = new Set();
                        isModified = true;
                        updateTitle();
                        requestRedraw(); // Use requestRedraw
                        showMessageBox("Success", "Canvas cleared.", 'info');
                    }
                });
        }
        clearCanvasBtn.addEventListener('click', clearCanvas);

        // --- Event Listeners ---
        // Unified pointer events for mouse and touch
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('touchstart', handlePointerDown, { passive: false });
        canvas.addEventListener('touchmove', handlePointerMove, { passive: false });
        canvas.addEventListener('touchend', handlePointerUp);
        canvas.addEventListener('touchcancel', handlePointerUp); // Handle touch cancellation

        canvas.addEventListener('wheel', handleWheel, { passive: false }); // Use passive: false for preventDefault on wheel

        // Tool buttons
        toolPaintBtn.addEventListener('click', () => switchTool('paint'));
        toolEraseBtn.addEventListener('click', () => switchTool('erase'));
        toolMoveBtn.addEventListener('click', () => switchTool('move'));

        // Color palette buttons
        const colors = [
            { name: 'Black', color: 'rgba(60, 60, 60, 1)' },
            { name: 'Blue', color: 'rgba(104, 136, 200, 1)' },
            { name: 'Red', color: 'rgba(255, 104, 104, 1)' },
            { name: 'Green', color: 'rgba(96, 160, 96, 1)' },
        ];

        colors.forEach((col, index) => {
            const button = document.createElement('button');
            button.textContent = col.name;
            button.className = `flex flex-col items-center justify-center p-2 rounded-md transition duration-200 text-white text-sm`;
            button.style.backgroundColor = col.color;
            if (col.name === 'Red') { // Default selected color
                button.classList.add('border-2', 'border-yellow-400');
                fillColor = col.color;
            } else {
                button.classList.add('border-2', 'border-transparent', 'hover:border-gray-600');
            }
            button.addEventListener('click', () => {
                fillColor = col.color;
                document.querySelectorAll('#color-palette button').forEach(btn => {
                    btn.classList.remove('border-2', 'border-yellow-400');
                    btn.classList.add('border-2', 'border-transparent', 'hover:border-gray-600');
                });
                button.classList.add('border-2', 'border-yellow-400');
                button.classList.remove('border-transparent', 'hover:border-gray-600');
            });
            colorPalette.appendChild(button);
        });

        // Undo/Redo buttons
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);

        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (event.ctrlKey || event.metaKey) {
                switch (event.key.toLowerCase()) {
                    case 'o':
                        event.preventDefault();
                        openProjectInput.click();
                        break;
                    case 's':
                        event.preventDefault();
                        if (event.shiftKey) {
                            saveProjectAs();
                        } else {
                            saveProject();
                        }
                        break;
                    case 'e':
                        event.preventDefault();
                        if (event.shiftKey) {
                            handleExportPng();
                        } else {
                            exportSVG();
                        }
                        break;
                    case 'l':
                        event.preventDefault();
                        loadObjInput.click();
                        break;
                    case 'r':
                        event.preventDefault();
                        clearCanvas();
                        break;
                    case 'z':
                        event.preventDefault();
                        undo();
                        break;
                    case 'y':
                        event.preventDefault();
                        redo();
                        break;
                    default:
                        break;
                }
            }
        });

        // Canvas resize observer
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                const { width, height } = entry.contentRect;
                canvas.width = width;
                canvas.height = height;
                requestRedraw(); // Use requestRedraw
            }
        });
        resizeObserver.observe(canvas.parentElement);

        // Show instructions on first run
        function showInstructionsIfNeeded() {
            const showInstructions = localStorage.getItem('show_instructions');
            if (showInstructions === null || showInstructions === 'true') {
                showMessageBox("Usage Instructions",
                    `Instructions:\n\n` +
                    `1) Load a 3D OBJ file with 'Load OBJ' (Ctrl+L).\n` +
                    `   The file is shown in top-down view (orthonormal projection).\n` +
                    `2) Paint/erase faces in 'Paint' or 'Erase' mode.\n` +
                    `3) Switch to 'Move' mode: painted faces convert to points.\n` +
                    `   (If no faces are painted, white points appear at all face centers.)\n` +
                    `4) In 'Move' mode, select points (click or marquee) to drag or rotate.\n` +
                    `   Points are drawn at a fixed size (e.g., 10px) in widget coordinates.\n` +
                    `5) While selecting, a selection rectangle appears (unfilled).\n` +
                    `6) Points snap to the nearest face when switching out of 'Move' mode.\n` +
                    `7) Pan with middle mouse button, or left-click drag when no tool is active.\n` +
                    `8) Zoom with Ctrl+scroll (zooms around cursor).\n` +
                    `9) Undo/Redo with Ctrl+Z / Ctrl+Y.\n\n` +
                    `Happy creating!`,
                    'info', false, true, "Don't show again"
                ).then(({ checkboxChecked }) => {
                    localStorage.setItem('show_instructions', !checkboxChecked);
                });
            }
        }

        // Initial setup
        window.onload = () => {
            requestRedraw(); // Initial draw
            showInstructionsIfNeeded();
        };

    </script>
</body>

</html>