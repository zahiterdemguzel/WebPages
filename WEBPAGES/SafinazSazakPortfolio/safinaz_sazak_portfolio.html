<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My 3D Portfolio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        /* Apply Inter font and dark background to the body */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow-x: hidden;
            /* Prevent horizontal scroll caused by off-screen elements */
            color: #e2e8f0;
            /* Light gray text */
        }

        /* Styling for each section containing a 3D cube */
        .cube-section {
            height: 60vh;
            /* Further reduced height to decrease vertical space between projects */
            display: flex;
            align-items: center;
            /* Vertically center content */
            justify-content: center;
            /* Horizontally center content */
            position: relative;
            /* Allows absolute positioning of children */
            overflow: hidden;
            /* Hides parts of the cube when it's off-screen */
            padding: 2rem;
            /* Add some padding around the sections */
            box-sizing: border-box;
            /* Include padding in the element's total width and height */
        }

        /* Container for the Three.js canvas */
        .cube-canvas-container {
            width: 50vw;
            /* Occupies half the viewport width */
            height: 70vh;
            /* Occupies 70% of the viewport height */
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            /* Positioned absolutely within its parent .cube-section */
            top: 50%;
            /* Start at the vertical center */
            transform: translateY(-50%);
            /* Adjust to truly center vertically */
            z-index: 10;
            /* Ensure canvas is above other content if needed */
        }

        /* Specific positioning for left-aligned cube containers */
        .cube-canvas-container.left {
            left: 0;
        }

        /* Specific positioning for right-aligned cube containers */
        .cube-canvas-container.right {
            right: 0;
        }

        /* Ensure canvas fills its container */
        canvas {
            display: block;
            width: 100% !important;
            /* Override Three.js inline width */
            height: 100% !important;
            /* Override Three.js inline height */
        }

        /* Styling for the text description next to the cube */
        .project-description {
            width: 50vw;
            /* Occupies the other half of the viewport width */
            height: 100%;
            /* Fill the height of the section */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4rem;
            /* Ample padding for readability */
            box-sizing: border-box;
            position: absolute;
            /* Positioned absolutely within its parent .cube-section */
            top: 0;
            z-index: 5;
            /* Ensure text is below canvas if they overlap */
        }

        /* Specific positioning for left-aligned text descriptions */
        .project-description.left-text {
            left: 0;
            text-align: left;
        }

        /* Specific positioning for right-aligned text descriptions */
        .project-description.right-text {
            right: 0;
            text-align: right;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .cube-section {
                flex-direction: column;
                /* Stack elements vertically */
                height: auto;
                /* Adjust height dynamically */
                min-height: 150vh;
                /* Ensure enough scroll space */
            }

            .cube-canvas-container,
            .project-description {
                position: relative;
                /* Revert to relative positioning */
                width: 100vw;
                /* Full width */
                height: 50vh;
                /* Half viewport height for each */
                top: auto;
                transform: none;
                padding: 1rem;
            }

            .cube-canvas-container.left,
            .cube-canvas-container.right,
            .project-description.left-text,
            .project-description.right-text {
                left: auto;
                right: auto;
            }

            .project-description {
                text-align: center;
                /* Center text on small screens */
            }
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-100">
    <header
        class="h-screen flex items-center justify-center bg-gradient-to-br from-blue-700 to-purple-800 text-white shadow-lg rounded-b-3xl">
        <h1 class="text-6xl md:text-7xl lg:text-8xl font-extrabold text-center drop-shadow-lg p-4">My 3D Portfolio</h1>
    </header>

    <main>
        <section id="section-1" class="cube-section">
            <div id="cube-container-1" class="cube-canvas-container left"></div>
            <div class="project-description right-text">
                <h2 class="text-4xl font-bold mb-4 text-blue-300">Project Alpha</h2>
                <p class="text-lg leading-relaxed">
                    A brief description of Project Alpha, highlighting its key features and technologies used.
                    This project focused on developing a robust and scalable solution for data visualization.
                    We leveraged modern frameworks and efficient algorithms to deliver a seamless user experience.
                </p>
            </div>
        </section>

        <section id="section-2" class="cube-section">
            <div id="cube-container-2" class="cube-canvas-container right"></div>
            <div class="project-description left-text">
                <h2 class="text-4xl font-bold mb-4 text-purple-300">Project Beta</h2>
                <p class="text-lg leading-relaxed">
                    Details about Project Beta, showcasing its innovative solutions and impact.
                    This initiative involved creating an interactive web application that revolutionized
                    how users interact with complex information, making it accessible and engaging.
                </p>
            </div>
        </section>

        <section id="section-3" class="cube-section">
            <div id="cube-container-3" class="cube-canvas-container left"></div>
            <div class="project-description right-text">
                <h2 class="text-4xl font-bold mb-4 text-green-300">Project Gamma</h2>
                <p class="text-lg leading-relaxed">
                    An overview of Project Gamma, focusing on its design principles and user experience.
                    We prioritized intuitive interfaces and responsive design to ensure a delightful experience
                    across all devices, reflecting our commitment to user-centric development.
                </p>
            </div>
        </section>

        <section id="section-4" class="cube-section">
            <div id="cube-container-4" class="cube-canvas-container right"></div>
            <div class="project-description left-text">
                <h2 class="text-4xl font-bold mb-4 text-yellow-300">Project Delta</h2>
                <p class="text-lg leading-relaxed">
                    Exploring Project Delta, its technical challenges and how they were overcome.
                    This project pushed the boundaries of performance optimization, tackling complex
                    algorithms to achieve lightning-fast processing times and real-time feedback.
                </p>
            </div>
        </section>

        <section id="section-5" class="cube-section">
            <div id="cube-container-5" class="cube-canvas-container left"></div>
            <div class="project-description right-text">
                <h2 class="text-4xl font-bold mb-4 text-red-300">Project Epsilon</h2>
                <p class="text-lg leading-relaxed">
                    A deep dive into Project Epsilon, its unique features and future potential.
                    This venture explored the integration of cutting-edge AI models to provide predictive
                    analytics, opening new avenues for informed decision-making and strategic planning.
                </p>
            </div>
        </section>

        <section id="section-6" class="cube-section">
            <div id="cube-container-6" class="cube-canvas-container right"></div>
            <div class="project-description left-text">
                <h2 class="text-4xl font-bold mb-4 text-teal-300">Project Zeta</h2>
                <p class="text-lg leading-relaxed">
                    Concluding with Project Zeta, summarizing its achievements and impact.
                    This final project consolidated our learning, delivering a comprehensive platform
                    that demonstrated mastery across various domains, from frontend design to backend architecture.
                </p>
            </div>
        </section>
    </main>

    <footer class="h-80 flex items-center justify-center bg-gray-800 text-gray-400 rounded-t-3xl">
        <p class="text-xl font-semibold">&copy; 2023 My Portfolio. All rights reserved.</p>
    </footer>

    <script>
        // Global arrays to hold Three.js scene components for each cube/model
        const scenes = [];
        const cameras = [];
        const renderers = [];
        const models = []; // Changed from 'cubes' to 'models' to reflect GLB
        const cubeContainers = []; // Stores references to the HTML container elements

        // Array of GLB model paths - now all pointing to the RobotExpressive model
        const glbModels = [
            'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
            'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
            'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
            'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
            'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
            'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb'
        ];

        /**
         * Initializes a single Three.js scene for a GLB model.
         * @param {string} containerId - The ID of the HTML div element that will host the canvas.
         * @param {boolean} isLeftAligned - True if the model should initially appear from the left, false for right.
         * @param {string} glbPath - The path to the GLB file.
         */
        function initCubeScene(containerId, isLeftAligned) {
            const container = document.getElementById(containerId);
            if (!container) {
                console.error(`Container with ID '${containerId}' not found.`);
                return;
            }
            cubeContainers.push(container); // Store the container reference

            // 1. Scene: The container for all 3D objects, lights, and cameras.
            const scene = new THREE.Scene();

            // 2. Camera: Defines the perspective from which the scene is viewed.
            const camera = new THREE.PerspectiveCamera(
                75, // FOV: Vertical field of view in degrees
                container.clientWidth / container.clientHeight, // Aspect Ratio: Width / Height
                0.1, // Near: Objects closer than this won't be rendered
                1000 // Far: Objects farther than this won't be rendered
            );

            // 3. Renderer: Renders the scene using WebGL.
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight); // Set renderer size to container size
            container.appendChild(renderer.domElement); // Add the canvas element to the HTML container

            // Add lighting to the scene for better visual appearance of the model
            // Increased intensity by 30%
            const ambientLight = new THREE.AmbientLight(0x404040, 1.3); // Soft white light, increased intensity
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8 * 1.3); // White light, increased intensity by 30%
            directionalLight.position.set(0, 1, 1).normalize(); // Position the light
            scene.add(directionalLight);

            // Placeholder cube while GLB loads
            const placeholderGeometry = new THREE.BoxGeometry(1, 1, 1);
            const placeholderMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, wireframe: true });
            const placeholderCube = new THREE.Mesh(placeholderGeometry, placeholderMaterial);
            placeholderCube.position.x = isLeftAligned ? -5 : 5; // Initial off-screen position
            scene.add(placeholderCube);
            models.push(placeholderCube); // Initially store the placeholder

            // Load GLB model
            const loader = new THREE.GLTFLoader();
            // Use glbModels array to get the path based on the index
            loader.load(glbModels[cubeContainers.indexOf(container)], function (gltf) {
                const model = gltf.scene;

                // Remove placeholder once model is loaded
                scene.remove(placeholderCube);

                // Adjust model scale and position as needed
                model.scale.set(0.5, 0.5, 0.5); // Example scale adjustment
                model.position.y = -1; // Example vertical adjustment to center the model

                // Set initial position of the model: off-screen left or right
                model.position.x = isLeftAligned ? -5 : 5; // Start further off-screen for a wider sweep
                model.position.z = 0; // Ensure z is 0 initially

                scene.add(model);

                // Replace placeholder with the actual model in the models array
                const modelIndex = models.indexOf(placeholderCube);
                if (modelIndex > -1) {
                    models[modelIndex] = model;
                }

            }, undefined, function (error) {
                console.error('An error occurred while loading the GLB model:', error);
                // Keep placeholder if loading fails
            });

            camera.position.z = 3; // Position the camera back to see the model clearly

            // Store all components for later access in the animation loop
            scenes.push(scene);
            cameras.push(camera);
            renderers.push(renderer);
            // The actual model will replace the placeholder in the 'models' array after loading
            // So, for now, 'models' array holds the placeholder, which will be updated later.

            // Add a resize listener for this specific scene's camera and renderer
            window.addEventListener('resize', () => onWindowResize(container, camera, renderer));
        }

        /**
         * Handles window resize events to update camera aspect ratio and renderer size.
         * This ensures the 3D scene scales correctly with the browser window.
         * @param {HTMLElement} container - The HTML container of the canvas.
         * @param {THREE.PerspectiveCamera} camera - The camera to update.
         * @param {THREE.WebGLRenderer} renderer - The renderer to update.
         */
        function onWindowResize(container, camera, renderer) {
            // Update camera aspect ratio based on new container size
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix(); // Update the camera's projection matrix after changing aspect

            // Update renderer size to match the new container size
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        /**
         * Easing function for smooth acceleration and deceleration.
         * @param {number} t - The input progress (0 to 1).
         * @returns {number} The eased output progress.
         */
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        /**
         * The main animation loop. This function is called repeatedly via requestAnimationFrame
         * to update model positions and rotations based on scroll, and render the scenes.
         */
        function animate() {
            requestAnimationFrame(animate); // Request the next animation frame

            // Get current scroll position of the window
            const scrollY = window.scrollY;
            const windowHeight = window.innerHeight;

            // Iterate over each model to update its animation
            models.forEach((model, index) => {
                const container = cubeContainers[index];
                if (!container) return; // Skip if container is not found

                // Get the parent section element
                const section = container.parentElement;
                const sectionRect = section.getBoundingClientRect();

                // Define the scroll range for the animation based on the section's visibility
                const sectionHeight = sectionRect.height;
                const viewportHeight = window.innerHeight;

                // Animation starts when the section's top is at this position (relative to viewport top)
                // This means the section is 10% visible from the bottom of the viewport
                const animationStartTop = viewportHeight - (viewportHeight * 0.1); // 90% down the viewport

                // Animation ends when the section's top is at this position (relative to viewport top)
                // This means the section is 10% visible from the top of the viewport
                const animationEndTop = -sectionHeight + (viewportHeight * 0.1); // 10% from the top of the section

                // Calculate the progress of the scroll within this defined range (0 to 1)
                // When sectionRect.top is at animationStartTop, progress is 0.
                // When sectionRect.top is at animationEndTop, progress is 1.
                let progress = (animationStartTop - sectionRect.top) / (animationStartTop - animationEndTop);
                progress = Math.max(0, Math.min(1, progress)); // Clamp progress between 0 and 1

                // Determine if the model should start from the left or right based on its index
                const isLeftAligned = index % 2 === 0;

                // Define the key positions for the translation animation
                // Initial and final X position: off-screen on the same side
                const initialX = isLeftAligned ? -5 : 5;
                // Mid X position: 0, which is the center of the model's local Three.js scene (and thus the center of its widget)
                const midX = 0;

                // Define the key rotations for the rotation animation (in radians)
                const degreesToRadians = (degrees) => degrees * (Math.PI / 180);
                let rotationStart, rotationPeak, rotationEnd;

                if (isLeftAligned) {
                    rotationStart = degreesToRadians(-90);
                    rotationPeak = degreesToRadians(0);
                    rotationEnd = degreesToRadians(90);
                } else {
                    // Invert rotation for right-aligned models
                    rotationStart = degreesToRadians(90);
                    rotationPeak = degreesToRadians(0);
                    rotationEnd = degreesToRadians(-90);
                }

                let currentX, currentRotationY;
                let easedSubProgress; // Eased progress for translation
                let linearSubProgress; // Linear progress for rotation

                // First half of the animation (progress 0 to 0.5): move from initial to mid-point, rotate from start to peak
                if (progress <= 0.5) {
                    const subProgress = progress * 2; // Normalize progress from 0-0.5 to 0-1
                    easedSubProgress = easeInOutCubic(subProgress);
                    linearSubProgress = subProgress; // Linear for rotation

                    currentX = THREE.MathUtils.lerp(initialX, midX, easedSubProgress);
                    currentRotationY = THREE.MathUtils.lerp(rotationStart, rotationPeak, linearSubProgress);
                }
                // Second half of the animation (progress 0.5 to 1): move from mid-point back to initial, rotate from peak to end
                else {
                    const subProgress = (progress - 0.5) * 2; // Normalize progress from 0.5-1 to 0-1
                    easedSubProgress = easeInOutCubic(subProgress);
                    linearSubProgress = subProgress; // Linear for rotation

                    currentX = THREE.MathUtils.lerp(midX, initialX, easedSubProgress);
                    currentRotationY = THREE.MathUtils.lerp(rotationPeak, rotationEnd, linearSubProgress);
                }

                // Apply the calculated position and rotation to the model
                model.position.x = currentX;
                model.rotation.y = currentRotationY;

                // Render the specific scene for this model
                renderers[index].render(scenes[index], cameras[index]);
            });
        }

        // Initialize all model scenes and start the animation loop once the window is fully loaded
        window.onload = function () {
            // Initialize 6 models, all using the same GLB path
            initCubeScene('cube-container-1', true);
            initCubeScene('cube-container-2', false);
            initCubeScene('cube-container-3', true);
            initCubeScene('cube-container-4', false);
            initCubeScene('cube-container-5', true);
            initCubeScene('cube-container-6', false);

            animate(); // Start the animation loop
        };
    </script>
</body>

</html>