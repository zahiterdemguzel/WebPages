<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Registration Form & Notes App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basic styling for the body and canvas */
        body {
            margin: 0;
            overflow: hidden;
            /* Prevent scrollbars due to canvas */
            font-family: "Inter", sans-serif;
            /* Use Inter font */
            background-color: #1a202c;
            /* Dark background color */
            color: #e2e8f0;
            /* Light text color */
        }

        canvas {
            display: block;
            /* Remove extra space below canvas */
            width: 100vw;
            /* Full viewport width */
            height: 100vh;
            /* Full viewport height */
        }

        /* Styling for the message box (for validation feedback) */
        #message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            /* Center horizontally */
            background-color: #2d3748;
            /* Dark background */
            color: #e2e8f0;
            /* Light text */
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            /* Rounded corners for the message box */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: none;
            /* Hidden by default */
            z-index: 100;
            /* Ensure it's on top */
            text-align: center;
        }
    </style>
</head>

<body>
    <div id="message-box"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <script type="module">
        // Declare global Three.js variables
        let scene, camera, renderer, controls;
        let raycaster = new THREE.Raycaster(); // Used for detecting clicks on 3D objects
        let mouse = new THREE.Vector2();     // Stores normalized mouse coordinates
        let activeField = null;              // Reference to the currently active (clicked) 3D field object
        let font;                            // Stores the loaded 3D font
        let cursorMesh;                      // 3D mesh for the blinking cursor
        let cursorBlinkInterval;             // Interval ID for cursor blinking

        // User ID for backend interaction (simulated for now)
        let currentUserId = null;

        // Global objects for managing forms and dashboard
        let allForms = {
            register: {
                fields: [],
                group: null,
                submitButton: null,
                switchButton: null, // Button text to switch to login
                switchButtonHitbox: null, // Invisible hitbox for the switch button
                backplate: null // Reference to the backplate for this form
            },
            login: {
                fields: [],
                group: null,
                submitButton: null,
                switchButton: null, // Button text to switch to register
                switchButtonHitbox: null, // Invisible hitbox for the switch button
                backplate: null
            },
            dashboard: {
                group: null,
                notebooks: [], // Array to store fetched notebooks
                addNotebookButton: null,
                logoutButton: null,
            },
            noteEditor: { // For editing existing notes or creating new ones
                group: null,
                titleField: null,
                contentField: null,
                saveButton: null,
                cancelButton: null,
                activeNoteId: null // Stores the ID of the note being edited/created
            }
        };
        let currentActiveScene = 'register'; // Tracks which main scene is visible ('register', 'login', 'dashboard', 'noteEditor')

        // Scale animation state
        let scaleAnimation = {
            isAnimating: false,
            startTime: 0,
            duration: 500, // 0.5 seconds for animation
            startScale: new THREE.Vector3(),
            endScale: new THREE.Vector3(),
            targetGroup: null,
            onComplete: null
        };

        // Get reference to the message box HTML element
        const messageBox = document.getElementById('message-box');

        /**
         * Displays a message in the message box.
         * @param {string} message - The message to display.
         * @param {string} type - The type of message ('info', 'success', 'error').
         */
        function showMessage(message, type = 'info') {
            messageBox.textContent = message;
            messageBox.style.display = 'block'; // Make the message box visible
            // Set background color based on message type
            if (type === 'error') {
                messageBox.style.backgroundColor = '#c53030'; // Red for error
            } else if (type === 'success') {
                messageBox.style.backgroundColor = '#38a169'; // Green for success
            } else {
                messageBox.style.backgroundColor = '#2d3748'; // Default dark gray
            }
            // Hide the message after 3 seconds
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 3000);
        }

        /**
         * Initializes the Three.js scene, camera, renderer, and controls.
         */
        function init() {
            // Scene: where all 3D objects are placed
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c); // Match body background color

            // Camera: defines the viewport
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5); // Position camera to view the form from a distance

            // Renderer: renders the scene onto the canvas
            renderer = new THREE.WebGLRenderer({ antialias: true }); // Enable anti-aliasing for smoother edges
            renderer.setSize(window.innerWidth, window.innerHeight); // Set renderer size to full window
            document.body.appendChild(renderer.domElement); // Add canvas to the DOM

            // OrbitControls: allows user to rotate, pan, and zoom the camera
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Enable damping for smoother camera movements
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; // Disable screen space panning
            controls.minDistance = 2; // Minimum zoom distance
            controls.maxDistance = 10; // Maximum zoom distance
            controls.maxPolarAngle = Math.PI / 2; // Prevent camera from going below the ground plane

            // Lighting: essential for seeing 3D objects
            // Key Light (main light source)
            const keyLight = new THREE.PointLight(0xffffff, 1.5, 100); // Color, intensity, distance
            keyLight.position.set(3, 3, 3); // Position: slightly above, to the side, and in front
            scene.add(keyLight);

            // Fill Light (fills in shadows, softer than key light)
            const fillLight = new THREE.PointLight(0xffffff, 0.8, 100);
            fillLight.position.set(-3, 1, 3); // Position: opposite key light, lower
            scene.add(fillLight);

            // Back Light (rim light, separates subject from background)
            const backLight = new THREE.PointLight(0xffffff, 0.6, 100);
            backLight.position.set(0, 4, -3); // Position: above and behind
            scene.add(backLight);

            // Load Font for 3D TextGeometry (labels and input text)
            const fontLoader = new THREE.FontLoader();
            // Using a CDN path for a standard Three.js font
            fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
                font = loadedFont; // Store the loaded font globally
                createForms(font); // Call function to create both 3D forms
                createDashboardElements(font); // Create dashboard elements
                createNoteEditorElements(font); // Create note editor elements
                createCursor(); // Create the 3D cursor
            });

            // Event Listeners
            window.addEventListener('resize', onWindowResize); // Handle window resizing
            renderer.domElement.addEventListener('click', onCanvasClick); // Handle clicks on the 3D canvas
            document.addEventListener('keydown', onKeyDown); // Handle keyboard input for 3D text
        }

        /**
         * Creates both the registration and login forms.
         * @param {THREE.Font} font - The loaded font for TextGeometry.
         */
        function createForms(font) {
            // --- Registration Form Setup ---
            const registerFieldNames = [
                { id: 'username', label: 'Username', type: 'text', placeholder: 'Enter username' },
                { id: 'email', label: 'Email', type: 'email', placeholder: 'Enter email' },
                { id: 'password', label: 'Password', type: 'password', placeholder: 'Enter password' },
                { id: 'confirmPassword', label: 'Confirm Password', type: 'password', placeholder: 'Confirm password' }
            ];
            createFormElements('register', registerFieldNames, font);

            // --- Login Form Setup ---
            const loginFieldNames = [
                { id: 'loginUsername', label: 'Username', type: 'text', placeholder: 'Enter username' },
                { id: 'loginPassword', label: 'Password', type: 'password', placeholder: 'Enter password' }
            ];
            createFormElements('login', loginFieldNames, font);

            // Both forms start at the same position (0,0,0) relative to the scene
            // Initially hide the login form
            allForms.login.group.visible = false;
            allForms.login.group.scale.set(0.001, 0.001, 0.001); // Start scaled down

            // Add switch buttons
            // "Already have an account? Login" button for the register form
            const switchToLoginText = "Already have an account? Login";
            const switchToLoginMesh = create3DText(switchToLoginText, font, 0.1, 0x8888ff); // Smaller text (0.1)
            // Position above the register button, with a clear gap
            const registerSubmitButtonY = allForms.register.submitButton.position.y;
            const registerSubmitButtonHeight = allForms.register.submitButton.geometry.parameters.height;
            // Calculate width for centering
            switchToLoginMesh.geometry.computeBoundingBox();
            const switchToLoginTextWidth = switchToLoginMesh.geometry.boundingBox.max.x - switchToLoginMesh.geometry.boundingBox.min.x;
            const switchButtonYPos = registerSubmitButtonY + registerSubmitButtonHeight / 2 + 0.1; // Adjusted Y offset (moved down)
            switchToLoginMesh.position.set(-switchToLoginTextWidth / 2, switchButtonYPos, 0.05); // Centered X position
            allForms.register.group.add(switchToLoginMesh);
            allForms.register.switchButton = switchToLoginMesh;

            // Create invisible hitbox for "Already have an account? Login"
            const hitboxGeometry = new THREE.BoxGeometry(switchToLoginTextWidth + 0.2, 0.25, 0.01); // Slightly larger than text
            const hitboxMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, depthWrite: false }); // Invisible
            const switchToLoginHitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
            switchToLoginHitbox.position.set(0, switchButtonYPos, 0.04); // Position behind text
            switchToLoginHitbox.userData.action = 'switchToLogin'; // Assign action to hitbox
            allForms.register.group.add(switchToLoginHitbox); // Add hitbox to group
            allForms.register.switchButtonHitbox = switchToLoginHitbox;


            // "Don't have an account? Register" button for the login form
            const switchToRegisterText = "Don't have an account? Register";
            const switchToRegisterMesh = create3DText(switchToRegisterText, font, 0.1, 0x8888ff); // Smaller text (0.1)
            // Position above the login button, with a clear gap
            const loginSubmitButtonY = allForms.login.submitButton.position.y;
            const loginSubmitButtonHeight = allForms.login.submitButton.geometry.parameters.height;
            // Calculate width for centering
            switchToRegisterMesh.geometry.computeBoundingBox();
            const switchToRegisterTextWidth = switchToRegisterMesh.geometry.boundingBox.max.x - switchToRegisterMesh.geometry.boundingBox.min.x;
            const switchButtonYPosLogin = loginSubmitButtonY + loginSubmitButtonHeight / 2 + 0.1; // Adjusted Y offset (moved down)
            switchToRegisterMesh.position.set(-switchToRegisterTextWidth / 2, switchButtonYPosLogin, 0.05); // Centered X position
            allForms.login.group.add(switchToRegisterMesh);
            allForms.login.switchButton = switchToRegisterMesh;
            allForms.login.switchButton.visible = false; // Initially hidden

            // Create invisible hitbox for "Don't have an account? Register"
            const hitboxGeometryLogin = new THREE.BoxGeometry(switchToRegisterTextWidth + 0.2, 0.25, 0.01); // Slightly larger than text
            const switchToRegisterHitbox = new THREE.Mesh(hitboxGeometryLogin, hitboxMaterial); // Reuse invisible material
            switchToRegisterHitbox.position.set(0, switchButtonYPosLogin, 0.04); // Position behind text
            switchToRegisterHitbox.userData.action = 'switchToRegister'; // Assign action to hitbox
            allForms.login.group.add(switchToRegisterHitbox); // Add hitbox to group
            allForms.login.switchButtonHitbox = switchToRegisterHitbox;
            allForms.login.switchButtonHitbox.visible = false; // Initially hidden
        }

        /**
         * Helper function to calculate the total height of a form including fields and button.
         * @param {Array} fieldNames - Array of field definitions.
         * @returns {number} The calculated total height.
         */
        function calculateFormHeight(fieldNames) {
            const fieldHeight = 0.8;
            const fieldSpacing = 1.2;
            const submitButtonHeight = fieldHeight * 0.8;
            const totalFieldSpace = fieldNames.length * fieldSpacing;
            return totalFieldSpace + submitButtonHeight + 0.5; // Add some extra padding
        }

        /**
         * Creates the 3D elements for a single form (panels, labels, input text, submit button, backplate).
         * @param {string} formType - 'register' or 'login'.
         * @param {Array} fieldNames - Array of field definitions for this form.
         * @param {THREE.Font} font - The loaded font for TextGeometry.
         */
        function createFormElements(formType, fieldNames, font) {
            // Dimensions and spacing for 3D form elements
            const fieldWidth = 2.5;
            const fieldHeight = 0.8;
            const fieldDepth = 0.15;
            const fieldSpacing = 1.2;
            const textInputSize = 0.15;

            const formGroup = new THREE.Group();
            scene.add(formGroup);
            allForms[formType].group = formGroup;

            let lastFieldYPos = 0;

            fieldNames.forEach((field, index) => {
                const yPos = (fieldNames.length - 1) * fieldSpacing / 2 - index * fieldSpacing;
                lastFieldYPos = yPos;

                // 3D Panel (the clickable area for the input field)
                const panelGeometry = new THREE.BoxGeometry(fieldWidth, fieldHeight, fieldDepth);
                const panelMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2d3748,
                    roughness: 0.7,
                    metalness: 0.2,
                    transparent: true,
                    opacity: 0.9
                });
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.position.set(0, yPos, 0);
                panelMesh.userData.fieldId = field.id;
                panelMesh.userData.formType = formType; // Link panel to its form type
                formGroup.add(panelMesh);

                // 3D Label Text
                const textGeometry = new THREE.TextGeometry(field.label, {
                    font: font,
                    size: 0.2,
                    height: 0.05,
                    curveSegments: 12
                });
                textGeometry.computeBoundingBox();
                const textMaterial = new THREE.MeshBasicMaterial({ color: 0xe2e8f0 });
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.set(-fieldWidth / 2 + 0.1, yPos + fieldHeight / 2 + 0.1, fieldDepth / 2 + 0.01);
                formGroup.add(textMesh);

                // Placeholder for the 3D input text
                const initialText = field.placeholder;
                const inputTextMesh = create3DText(initialText, font, textInputSize, 0xffffff);
                inputTextMesh.position.set(-fieldWidth / 2 + 0.1, yPos - 0.1, fieldDepth / 2 + 0.01);
                formGroup.add(inputTextMesh);

                allForms[formType].fields.push({
                    id: field.id,
                    label: field.label,
                    type: field.type,
                    panelMesh: panelMesh,
                    textMesh: textMesh,
                    inputTextMesh: inputTextMesh,
                    currentValue: '',
                    placeholder: field.placeholder
                });
            });

            // Add a 3D Submit Button
            const submitButtonGeometry = new THREE.BoxGeometry(fieldWidth, fieldHeight * 0.8, fieldDepth);
            const submitButtonMaterial = new THREE.MeshStandardMaterial({
                color: 0x63b3ed,
                roughness: 0.7,
                metalness: 0.2
            });
            const submitButtonMesh = new THREE.Mesh(submitButtonGeometry, submitButtonMaterial);
            // Adjust position for login button specifically
            let submitButtonYOffset = 0;
            if (formType === 'login') {
                submitButtonYOffset = -0.3; // Move login button down by 0.3 units
            }
            submitButtonMesh.position.set(0, lastFieldYPos - fieldSpacing + submitButtonYOffset, 0);
            submitButtonMesh.userData.fieldId = 'submit';
            submitButtonMesh.userData.formType = formType; // Link submit button to its form type
            formGroup.add(submitButtonMesh);
            allForms[formType].submitButton = submitButtonMesh;

            // 3D Text for the Submit button
            const submitText = formType === 'register' ? 'Register' : 'Login';
            const submitTextGeometry = new THREE.TextGeometry(submitText, {
                font: font,
                size: 0.25,
                height: 0.05,
                curveSegments: 12
            });
            submitTextGeometry.computeBoundingBox();
            const submitTextWidth = submitTextGeometry.boundingBox.max.x - submitTextGeometry.boundingBox.min.x;
            const submitTextMesh = new THREE.Mesh(submitTextGeometry, new THREE.MeshBasicMaterial({ color: 0xffffff }));
            submitTextMesh.position.set(-submitTextWidth / 2, lastFieldYPos - fieldSpacing + submitButtonYOffset, fieldDepth / 2 + 0.01);
            formGroup.add(submitTextMesh);

            // Calculate overall form bounds for backplate positioning
            const topOfFirstField = (fieldNames.length - 1) * fieldSpacing / 2 + fieldHeight / 2;
            const bottomOfSubmitButton = (lastFieldYPos - fieldSpacing + submitButtonYOffset) - (fieldHeight * 0.8) / 2;

            const backplateHeight = topOfFirstField - bottomOfSubmitButton + 0.9;
            const backplateYPosition = (topOfFirstField + bottomOfSubmitButton) / 2 + 0.1;

            // Add a backplate behind the form
            const backplateWidth = fieldWidth * 1.2;
            const backplateDepth = 0.05 * 3; // 3X thicker backplate
            const backplateGeometry = new THREE.BoxGeometry(backplateWidth, backplateHeight, backplateDepth);
            const backplateMaterial = new THREE.MeshStandardMaterial({
                color: 0x242e3a,
                roughness: 0.8,
                metalness: 0.1
            });
            const backplateMesh = new THREE.Mesh(backplateGeometry, backplateMaterial);
            backplateMesh.position.set(0, backplateYPosition, -fieldDepth / 2 - backplateDepth / 2 - 0.05);
            formGroup.add(backplateMesh);
            allForms[formType].backplate = backplateMesh;
        }

        /**
         * Creates the 3D elements for the dashboard (add note button, logout button).
         * @param {THREE.Font} font - The loaded font.
         */
        function createDashboardElements(font) {
            const dashboardGroup = new THREE.Group();
            scene.add(dashboardGroup);
            allForms.dashboard.group = dashboardGroup;

            // Initially hide dashboard
            dashboardGroup.visible = false;
            dashboardGroup.scale.set(0.001, 0.001, 0.001);

            const buttonWidth = 2.0;
            const buttonHeight = 0.6;
            const buttonDepth = 0.1;
            const buttonSpacing = 0.8; // Spacing between dashboard buttons/notes

            // Add New Notebook Button
            const addNoteGeometry = new THREE.BoxGeometry(buttonWidth, buttonHeight, buttonDepth);
            const addNoteMaterial = new THREE.MeshStandardMaterial({ color: 0x48bb78, roughness: 0.7, metalness: 0.2 }); // Green
            const addNoteMesh = new THREE.Mesh(addNoteGeometry, addNoteMaterial);
            addNoteMesh.position.set(0, 2.0, 0); // Position at the top of the dashboard
            addNoteMesh.userData.action = 'addNotebook';
            dashboardGroup.add(addNoteMesh);
            allForms.dashboard.addNotebookButton = addNoteMesh;

            const addNoteText = create3DText('Add New Notebook', font, 0.18, 0xffffff);
            addNoteText.position.set(-addNoteText.geometry.boundingBox.max.x / 2, 2.0, buttonDepth / 2 + 0.01);
            dashboardGroup.add(addNoteText);

            // Logout Button
            const logoutGeometry = new THREE.BoxGeometry(buttonWidth * 0.8, buttonHeight * 0.8, buttonDepth);
            const logoutMaterial = new THREE.MeshStandardMaterial({ color: 0xe53e3e, roughness: 0.7, metalness: 0.2 }); // Red
            const logoutMesh = new THREE.Mesh(logoutGeometry, logoutMaterial);
            logoutMesh.position.set(0, -2.5, 0); // Position at the bottom of the dashboard
            logoutMesh.userData.action = 'logout';
            dashboardGroup.add(logoutMesh);
            allForms.dashboard.logoutButton = logoutMesh;

            const logoutText = create3DText('Logout', font, 0.15, 0xffffff);
            logoutText.position.set(-logoutText.geometry.boundingBox.max.x / 2, -2.5, buttonDepth / 2 + 0.01);
            dashboardGroup.add(logoutText);
        }

        /**
         * Creates the 3D elements for the note editor.
         * @param {THREE.Font} font - The loaded font.
         */
        function createNoteEditorElements(font) {
            const editorGroup = new THREE.Group();
            scene.add(editorGroup);
            allForms.noteEditor.group = editorGroup;

            editorGroup.visible = false;
            editorGroup.scale.set(0.001, 0.001, 0.001);

            const fieldWidth = 3.5;
            const fieldHeight = 0.8;
            const fieldDepth = 0.15;
            const fieldSpacing = 1.2;
            const textInputSize = 0.15;

            // Title Field
            const titlePanelGeometry = new THREE.BoxGeometry(fieldWidth, fieldHeight, fieldDepth);
            const titlePanelMaterial = new THREE.MeshStandardMaterial({ color: 0x2d3748, roughness: 0.7, metalness: 0.2, transparent: true, opacity: 0.9 });
            const titlePanelMesh = new THREE.Mesh(titlePanelGeometry, titlePanelMaterial);
            titlePanelMesh.position.set(0, 1.0, 0);
            titlePanelMesh.userData.fieldId = 'noteTitle';
            titlePanelMesh.userData.formType = 'noteEditor';
            editorGroup.add(titlePanelMesh);

            const titleLabel = create3DText('Title', font, 0.2, 0xe2e8f0);
            titleLabel.position.set(-fieldWidth / 2 + 0.1, 1.0 + fieldHeight / 2 + 0.1, fieldDepth / 2 + 0.01);
            editorGroup.add(titleLabel);

            const titleInputMesh = create3DText('', font, textInputSize, 0xffffff);
            titleInputMesh.position.set(-fieldWidth / 2 + 0.1, 1.0 - 0.1, fieldDepth / 2 + 0.01);
            editorGroup.add(titleInputMesh);

            allForms.noteEditor.titleField = {
                id: 'noteTitle',
                panelMesh: titlePanelMesh,
                inputTextMesh: titleInputMesh,
                currentValue: '',
                placeholder: 'Enter note title'
            };

            // Content Field (simplified to single line for 3D text)
            const contentPanelGeometry = new THREE.BoxGeometry(fieldWidth, fieldHeight * 2, fieldDepth); // Taller for content
            const contentPanelMaterial = new THREE.MeshStandardMaterial({ color: 0x2d3748, roughness: 0.7, metalness: 0.2, transparent: true, opacity: 0.9 });
            const contentPanelMesh = new THREE.Mesh(contentPanelGeometry, contentPanelMaterial);
            contentPanelMesh.position.set(0, -1.0, 0); // Position below title
            contentPanelMesh.userData.fieldId = 'noteContent';
            contentPanelMesh.userData.formType = 'noteEditor';
            editorGroup.add(contentPanelMesh);

            const contentLabel = create3DText('Content', font, 0.2, 0xe2e8f0);
            contentLabel.position.set(-fieldWidth / 2 + 0.1, -1.0 + (fieldHeight * 2) / 2 + 0.1, fieldDepth / 2 + 0.01);
            editorGroup.add(contentLabel);

            const contentInputMesh = create3DText('', font, textInputSize, 0xffffff);
            contentInputMesh.position.set(-fieldWidth / 2 + 0.1, -1.0 + (fieldHeight * 2) / 2 - 0.1, fieldDepth / 2 + 0.01); // Position at top of content area
            editorGroup.add(contentInputMesh);

            allForms.noteEditor.contentField = {
                id: 'noteContent',
                panelMesh: contentPanelMesh,
                inputTextMesh: contentInputMesh,
                currentValue: '',
                placeholder: 'Enter note content'
            };

            // Save Button
            const saveButtonGeometry = new THREE.BoxGeometry(1.0, 0.5, 0.1);
            const saveButtonMaterial = new THREE.MeshStandardMaterial({ color: 0x48bb78, roughness: 0.7, metalness: 0.2 });
            const saveButtonMesh = new THREE.Mesh(saveButtonGeometry, saveButtonMaterial);
            saveButtonMesh.position.set(-0.7, -2.5, 0);
            saveButtonMesh.userData.action = 'saveNote';
            editorGroup.add(saveButtonMesh);
            allForms.noteEditor.saveButton = saveButtonMesh;

            const saveButtonText = create3DText('Save', font, 0.15, 0xffffff);
            saveButtonText.position.set(-0.7 - saveButtonText.geometry.boundingBox.max.x / 2, -2.5, 0.05);
            editorGroup.add(saveButtonText);

            // Cancel Button
            const cancelButtonGeometry = new THREE.BoxGeometry(1.0, 0.5, 0.1);
            const cancelButtonMaterial = new THREE.MeshStandardMaterial({ color: 0xe53e3e, roughness: 0.7, metalness: 0.2 });
            const cancelButtonMesh = new THREE.Mesh(cancelButtonGeometry, cancelButtonMaterial);
            cancelButtonMesh.position.set(0.7, -2.5, 0);
            cancelButtonMesh.userData.action = 'cancelEdit';
            editorGroup.add(cancelButtonMesh);
            allForms.noteEditor.cancelButton = cancelButtonMesh;

            const cancelButtonText = create3DText('Cancel', font, 0.15, 0xffffff);
            cancelButtonText.position.set(0.7 - cancelButtonText.geometry.boundingBox.max.x / 2, -2.5, 0.05);
            editorGroup.add(cancelButtonText);
        }


        /**
         * Helper function to create 3D text.
         * @param {string} text - The text string.
         * @param {THREE.Font} font - The loaded font.
         * @param {number} size - Font size.
         * @param {number} color - Hex color for the text.
         * @returns {THREE.Mesh} The 3D text mesh.
         */
        function create3DText(text, font, size, color) {
            const textGeometry = new THREE.TextGeometry(text, {
                font: font,
                size: size,
                height: size * 0.2, // Extrusion depth relative to size
                curveSegments: 12 // Ensure text is smooth
            });
            textGeometry.computeBoundingBox();
            const textMaterial = new THREE.MeshBasicMaterial({ color: color });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            return textMesh;
        }

        /**
         * Creates the 3D cursor mesh.
         */
        function createCursor() {
            const cursorGeometry = new THREE.BoxGeometry(0.02, 0.2, 0.01); // Thin vertical bar
            const cursorMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White cursor
            cursorMesh = new THREE.Mesh(cursorGeometry, cursorMaterial);
            cursorMesh.visible = false; // Hidden by default
            scene.add(cursorMesh);

            // Start blinking interval
            cursorBlinkInterval = setInterval(() => {
                if (activeField) {
                    cursorMesh.visible = !cursorMesh.visible;
                } else {
                    cursorMesh.visible = false; // Hide if no active field
                }
            }, 500); // Blink every 500ms
        }

        /**
         * Updates the 3D input text mesh for the active field.
         * @param {string} newText - The new text string.
         */
        function update3DInputText(newText) {
            if (!activeField || !font) return;

            // Remove old text mesh from its parent (formGroup)
            if (activeField.inputTextMesh && activeField.inputTextMesh.parent) {
                activeField.inputTextMesh.geometry.dispose(); // Dispose old geometry
                activeField.inputTextMesh.material.dispose(); // Dispose old material
                activeField.inputTextMesh.parent.remove(activeField.inputTextMesh); // Remove from its parent group
            }

            // Truncate text if it exceeds a certain length (e.g., 20 characters)
            const maxLength = (activeField.id === 'noteContent') ? 50 : 20; // Allow more for content
            let displayNewText = newText;
            if (newText.length > maxLength) {
                displayNewText = newText.substring(0, maxLength - 3) + '...';
            }

            // Create new text mesh
            const textInputSize = 0.15;
            const newTextMesh = create3DText(displayNewText, font, textInputSize, 0xffffff);
            newTextMesh.position.copy(activeField.panelMesh.position); // Start at panel's position
            newTextMesh.position.x -= activeField.panelMesh.geometry.parameters.width / 2 - 0.1; // Align left
            newTextMesh.position.y -= 0.1; // Position slightly below center of panel
            newTextMesh.position.z += activeField.panelMesh.geometry.parameters.depth / 2 + 0.01; // In front of panel

            // Add new text mesh to the correct group
            if (currentActiveScene === 'register' || currentActiveScene === 'login') {
                allForms[currentActiveScene].group.add(newTextMesh);
            } else if (currentActiveScene === 'noteEditor') {
                allForms.noteEditor.group.add(newTextMesh);
            }
            activeField.inputTextMesh = newTextMesh; // Update reference

            // Update cursor position
            updateCursorPosition();
        }

        /**
         * Updates the cursor's position based on the active field's text.
         */
        function updateCursorPosition() {
            if (activeField && activeField.inputTextMesh) {
                // Ensure bounding box is computed for accurate width calculation
                activeField.inputTextMesh.geometry.computeBoundingBox();
                const textWidth = activeField.inputTextMesh.geometry.boundingBox.max.x - activeField.inputTextMesh.geometry.boundingBox.min.x;

                // Position cursor at the end of the text
                cursorMesh.position.copy(activeField.inputTextMesh.position);
                cursorMesh.position.x += textWidth + 0.05; // Add a small offset
                cursorMesh.position.y += activeField.inputTextMesh.geometry.parameters.size / 2 - 0.05; // Center vertically with text
                cursorMesh.position.z += 0.005; // Slightly in front of text
                cursorMesh.visible = true; // Ensure cursor is visible when active
            } else {
                cursorMesh.visible = false; // Hide cursor if no active field
            }
        }

        /**
         * Smoothly animates the scale of a Three.js group.
         * @param {THREE.Group} targetGroup - The group to animate.
         * @param {THREE.Vector3} endScale - The target scale.
         * @param {Function} [onComplete=null] - Optional callback to execute after animation.
         */
        function startScaleAnimation(targetGroup, endScale, onComplete = null) {
            scaleAnimation.isAnimating = true;
            scaleAnimation.startTime = performance.now();
            scaleAnimation.targetGroup = targetGroup;
            scaleAnimation.startScale.copy(targetGroup.scale);
            scaleAnimation.endScale.copy(endScale);
            scaleAnimation.onComplete = onComplete;
        }

        /**
         * Updates the scale animation frame by frame.
         */
        function updateScaleAnimation() {
            if (!scaleAnimation.isAnimating) return;

            const elapsed = performance.now() - scaleAnimation.startTime;
            const progress = Math.min(elapsed / scaleAnimation.duration, 1);

            scaleAnimation.targetGroup.scale.lerpVectors(scaleAnimation.startScale, scaleAnimation.endScale, progress);

            if (progress === 1) {
                scaleAnimation.isAnimating = false;
                if (scaleAnimation.onComplete) {
                    scaleAnimation.onComplete();
                }
            }
        }

        /**
         * Switches between main application scenes with a scale animation.
         * @param {string} newSceneType - The scene to switch to ('register', 'login', 'dashboard', 'noteEditor').
         */
        function switchToScene(newSceneType) {
            if (scaleAnimation.isAnimating || currentActiveScene === newSceneType) return;

            // Deactivate any active field before switching
            if (activeField) {
                if (activeField.currentValue === '') {
                    // Revert placeholder text if empty
                    if (activeField.placeholder) {
                        update3DInputText(activeField.placeholder);
                    } else {
                        // If no placeholder, just clear the text
                        update3DInputText('');
                    }
                }
                activeField = null;
                cursorMesh.visible = false;
            }

            let oldGroup = null;
            if (currentActiveScene === 'register' || currentActiveScene === 'login') {
                oldGroup = allForms[currentActiveScene].group;
            } else if (currentActiveScene === 'dashboard') {
                oldGroup = allForms.dashboard.group;
            } else if (currentActiveScene === 'noteEditor') {
                oldGroup = allForms.noteEditor.group;
            }


            let newGroup = null;
            if (newSceneType === 'register' || newSceneType === 'login') {
                newGroup = allForms[newSceneType].group;
            } else if (newSceneType === 'dashboard') {
                newGroup = allForms.dashboard.group;
            } else if (newSceneType === 'noteEditor') {
                newGroup = allForms.noteEditor.group;
            }

            // Scale down the old group
            if (oldGroup) {
                startScaleAnimation(oldGroup, new THREE.Vector3(0.001, 0.001, 0.001), () => {
                    oldGroup.visible = false;
                    // Hide switch buttons for old form
                    if (allForms[currentActiveScene].switchButton) allForms[currentActiveScene].switchButton.visible = false;
                    if (allForms[currentActiveScene].switchButtonHitbox) allForms[currentActiveScene].switchButtonHitbox.visible = false;

                    // Scale up the new group
                    if (newGroup) {
                        newGroup.visible = true;
                        // Show switch buttons for new form if applicable
                        if (allForms[newSceneType].switchButton) allForms[newSceneType].switchButton.visible = true;
                        if (allForms[newSceneType].switchButtonHitbox) allForms[newSceneType].switchButtonHitbox.visible = true;
                        startScaleAnimation(newGroup, new THREE.Vector3(1, 1, 1));
                    }
                    currentActiveScene = newSceneType;

                    // Special actions after scene switch
                    if (newSceneType === 'dashboard') {
                        fetchNotebooks(); // Fetch notes when dashboard is shown
                    }
                });
            } else {
                // If there's no old group (e.g., initial load to register), just show the new one
                if (newGroup) {
                    newGroup.visible = true;
                    if (allForms[newSceneType].switchButton) allForms[newSceneType].switchButton.visible = true;
                    if (allForms[newSceneType].switchButtonHitbox) allForms[newSceneType].switchButtonHitbox.visible = true;
                    newGroup.scale.set(1, 1, 1); // Ensure it's at full scale
                }
                currentActiveScene = newSceneType;
            }
        }

        /**
         * Handles window resizing events to update camera aspect ratio and renderer size.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); // Update camera's projection matrix
            renderer.setSize(window.innerWidth, window.innerHeight); // Update renderer size
        }

        /**
         * Handles click events on the canvas to detect interaction with 3D elements.
         * @param {MouseEvent} event - The click event object.
         */
        function onCanvasClick(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update the raycaster with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Find objects intersecting the ray (from the camera through the mouse position)
            // true for recursive check, meaning it will check children of children
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object; // The first (closest) intersected object

                // Handle global actions (like form switching or dashboard actions)
                if (clickedObject.userData.action) {
                    if (clickedObject.userData.action === 'switchToLogin') {
                        switchToScene('login');
                        return;
                    } else if (clickedObject.userData.action === 'switchToRegister') {
                        switchToScene('register');
                        return;
                    } else if (clickedObject.userData.action === 'addNotebook') {
                        openNoteEditor(null); // Open editor for new note
                        return;
                    } else if (clickedObject.userData.action === 'logout') {
                        // Simulate logout
                        currentUserId = null; // Clear user ID on logout
                        showMessage("Logged out successfully!", "success");
                        switchToScene('login');
                        return;
                    } else if (clickedObject.userData.action === 'editNotebook') {
                        openNoteEditor(clickedObject.userData.notebookId);
                        return;
                    } else if (clickedObject.userData.action === 'deleteNotebook') {
                        deleteNotebook(clickedObject.userData.notebookId);
                        return;
                    } else if (clickedObject.userData.action === 'saveNote') {
                        saveNote();
                        return;
                    } else if (clickedObject.userData.action === 'cancelEdit') {
                        switchToScene('dashboard');
                        return;
                    }
                }

                // Handle form field clicks (only for currently active form/scene)
                if (clickedObject.userData.fieldId && clickedObject.userData.formType === currentActiveScene) {
                    if (clickedObject.userData.fieldId === 'submit') {
                        handleSubmit(currentActiveScene); // Pass form type to handleSubmit
                        return;
                    }

                    // For note editor fields
                    const field = (currentActiveScene === 'noteEditor') ?
                        (clickedObject.userData.fieldId === 'noteTitle' ? allForms.noteEditor.titleField : allForms.noteEditor.contentField) :
                        allForms[currentActiveScene].fields.find(f => f.id === clickedObject.userData.fieldId);

                    if (field) {
                        if (activeField === field) return;

                        if (activeField && activeField.currentValue === '') {
                            update3DInputText(activeField.placeholder);
                        }

                        activeField = field;
                        if (activeField.currentValue === '') {
                            update3DInputText('');
                        } else {
                            update3DInputText(activeField.currentValue);
                        }
                        updateCursorPosition();
                    }
                }
            } else {
                // If clicked outside any 3D object, hide the currently active 3D input
                if (activeField) {
                    if (activeField.currentValue === '') {
                        update3DInputText(activeField.placeholder);
                    }
                    activeField = null;
                    cursorMesh.visible = false;
                }
            }
        }

        /**
         * Handles keyboard input for the 3D text fields.
         * @param {KeyboardEvent} event - The keyboard event object.
         */
        function onKeyDown(event) {
            if (!activeField) return; // Only process if a field is active

            const key = event.key;

            if (key.length === 1 && (key.match(/[a-zA-Z0-9@._-]/) || key === ' ')) {
                // Allow alphanumeric characters, common symbols for email/password, and space
                activeField.currentValue += key;
                update3DInputText(activeField.currentValue);
            } else if (key === 'Backspace') {
                activeField.currentValue = activeField.currentValue.slice(0, -1);
                update3DInputText(activeField.currentValue);
            } else if (key === 'Enter') {
                // Optionally submit the form or simply deactivate the field
                if (currentActiveScene === 'register' || currentActiveScene === 'login') {
                    handleSubmit(currentActiveScene);
                } else if (currentActiveScene === 'noteEditor') {
                    saveNote();
                }
            }
            // Prevent default browser actions for handled keys (e.g., backspace navigating back)
            event.preventDefault();
        }

        /**
         * Handles the form submission logic for login/register.
         * @param {string} formType - The type of form being submitted ('register' or 'login').
         */
        function handleSubmit(formType) {
            const formData = {};
            allForms[formType].fields.forEach(field => {
                formData[field.id] = field.currentValue;
            });

            if (formType === 'register') {
                if (!formData.username || !formData.email || !formData.password || !formData.confirmPassword) {
                    showMessage('Registration: All fields are required!', 'error');
                    return;
                }
                if (formData.password !== formData.confirmPassword) {
                    showMessage('Registration: Passwords do not match!', 'error');
                    return;
                }
                if (formData.password.length < 6) {
                    showMessage('Registration: Password must be at least 6 characters long!', 'error');
                    return;
                }
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(formData.email)) {
                    showMessage('Registration: Please enter a valid email address!', 'error');
                    return;
                }
                console.log('Register Form Data:', formData);
                showMessage('Registration successful!', 'success');
                // In a real app, you'd create user account here
                switchToScene('login'); // After registration, go to login
            } else if (formType === 'login') {
                if (!formData.loginUsername || !formData.loginPassword) {
                    showMessage('Login: Both username and password are required!', 'error');
                    return;
                }
                // Simulate login success
                if (formData.loginUsername === 'test' && formData.loginPassword === 'password') {
                    currentUserId = 'testUser123'; // Assign a fixed user ID on successful login
                    showMessage('Login successful! Welcome to your dashboard.', 'success');
                    switchToScene('dashboard'); // Switch to dashboard on successful login
                } else {
                    showMessage('Login failed: Invalid username or password.', 'error');
                }
            }
        }

        /**
         * Fetches notebooks from the backend API.
         */
        async function fetchNotebooks() {
            if (!currentUserId) {
                showMessage("Please log in to view notebooks.", "error");
                return;
            }
            try {
                const response = await fetch('http://localhost:3000/api/notebooks', {
                    headers: {
                        'X-User-Id': currentUserId // Send user ID with request
                    }
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const notebooks = await response.json();
                allForms.dashboard.notebooks = notebooks;
                renderNotebooks(); // Re-render notes whenever data changes
            } catch (error) {
                console.error("Error fetching notebooks:", error);
                showMessage("Failed to load notebooks.", "error");
            }
        }

        /**
         * Renders the 3D notebook elements on the dashboard.
         */
        function renderNotebooks() {
            // Clear existing notebook meshes (except fixed buttons)
            const removableMeshes = [];
            allForms.dashboard.group.children.forEach(child => {
                if (child.userData.isNotebookItem) { // Custom flag to identify notebook items
                    removableMeshes.push(child);
                }
            });
            removableMeshes.forEach(mesh => {
                mesh.geometry.dispose();
                mesh.material.dispose();
                allForms.dashboard.group.remove(mesh);
            });

            const startY = 1.0; // Starting Y position for the first note
            const noteHeight = 0.6;
            const noteSpacing = 0.8;
            const noteWidth = 3.0;

            allForms.dashboard.notebooks.forEach((notebook, index) => {
                const yPos = startY - (index * noteSpacing);

                // Notebook Panel
                const panelGeometry = new THREE.BoxGeometry(noteWidth, noteHeight, 0.1);
                const panelMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5568, roughness: 0.7, metalness: 0.2 });
                const panelMesh = new THREE.Mesh(panelGeometry, panelMaterial);
                panelMesh.position.set(0, yPos, 0);
                panelMesh.userData.action = 'editNotebook'; // Click panel to edit
                panelMesh.userData.notebookId = notebook._id; // Use _id from MongoDB
                panelMesh.userData.isNotebookItem = true; // Flag for removal
                allForms.dashboard.group.add(panelMesh);

                // Notebook Title
                const titleText = notebook.title || 'Untitled Notebook';
                const titleMesh = create3DText(titleText, font, 0.15, 0xe2e8f0);
                titleMesh.position.set(-noteWidth / 2 + 0.1, yPos + 0.1, 0.05);
                titleMesh.userData.action = 'editNotebook'; // Also clickable
                titleMesh.userData.notebookId = notebook._id; // Use _id from MongoDB
                titleMesh.userData.isNotebookItem = true; // Flag for removal
                allForms.dashboard.group.add(titleMesh);

                // Delete Button
                const deleteButtonGeometry = new THREE.BoxGeometry(0.5, 0.4, 0.05);
                const deleteButtonMaterial = new THREE.MeshStandardMaterial({ color: 0xe53e3e, roughness: 0.7, metalness: 0.2 });
                const deleteButtonMesh = new THREE.Mesh(deleteButtonGeometry, deleteButtonMaterial);
                deleteButtonMesh.position.set(noteWidth / 2 - 0.3, yPos, 0.05); // Position on the right
                deleteButtonMesh.userData.action = 'deleteNotebook';
                deleteButtonMesh.userData.notebookId = notebook._id; // Use _id from MongoDB
                deleteButtonMesh.userData.isNotebookItem = true; // Flag for removal
                allForms.dashboard.group.add(deleteButtonMesh);

                const deleteText = create3DText('X', font, 0.2, 0xffffff); // Simple 'X' for delete
                deleteText.position.set(noteWidth / 2 - 0.3 - deleteText.geometry.boundingBox.max.x / 2, yPos, 0.06);
                deleteText.userData.action = 'deleteNotebook';
                deleteText.userData.notebookId = notebook._id; // Use _id from MongoDB
                deleteText.userData.isNotebookItem = true; // Flag for removal
                allForms.dashboard.group.add(deleteText);
            });

            // Adjust position of Add New Notebook button to be above the list
            if (allForms.dashboard.addNotebookButton) {
                allForms.dashboard.addNotebookButton.position.y = startY + noteSpacing;
                allForms.dashboard.addNotebookButton.children[0].position.y = startY + noteSpacing; // Adjust text too
            }
        }

        /**
         * Opens the note editor, populating with existing note data if provided.
         * @param {string|null} notebookId - The ID of the notebook to edit, or null for a new note.
         */
        async function openNoteEditor(notebookId) {
            allForms.noteEditor.activeNoteId = notebookId;
            let noteToEdit = { title: '', content: '' };

            if (notebookId) {
                try {
                    const response = await fetch(`http://localhost:3000/api/notebooks/${notebookId}`, {
                        headers: {
                            'X-User-Id': currentUserId
                        }
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    noteToEdit = await response.json();
                } catch (error) {
                    console.error("Error fetching note for editing:", error);
                    showMessage("Failed to load note for editing.", "error");
                    return;
                }
            }

            allForms.noteEditor.titleField.currentValue = noteToEdit.title;
            allForms.noteEditor.contentField.currentValue = noteToEdit.content;

            update3DInputTextForEditor(allForms.noteEditor.titleField, noteToEdit.title);
            update3DInputTextForEditor(allForms.noteEditor.contentField, noteToEdit.content);

            switchToScene('noteEditor');
        }

        /**
         * Helper to update 3D text for editor fields, handling placeholders.
         * @param {object} field - The field object (titleField or contentField).
         * @param {string} text - The text to display.
         */
        function update3DInputTextForEditor(field, text) {
            if (field.inputTextMesh && field.inputTextMesh.parent) {
                field.inputTextMesh.geometry.dispose();
                field.inputTextMesh.material.dispose();
                field.inputTextMesh.parent.remove(field.inputTextMesh);
            }

            const maxLength = (field.id === 'noteContent') ? 50 : 20;
            let displayNewText = text;
            if (text.length > maxLength) {
                displayNewText = text.substring(0, maxLength - 3) + '...';
            } else if (text === '' && field.placeholder) {
                displayNewText = field.placeholder;
            }

            const newTextMesh = create3DText(displayNewText, font, 0.15, 0xffffff);
            newTextMesh.position.copy(field.panelMesh.position);
            newTextMesh.position.x -= field.panelMesh.geometry.parameters.width / 2 - 0.1;
            newTextMesh.position.y -= (field.id === 'noteContent' ? (field.panelMesh.geometry.parameters.height / 2 - 0.1) : 0.1); // Adjust Y for content field
            newTextMesh.position.z += field.panelMesh.geometry.parameters.depth / 2 + 0.01;
            allForms.noteEditor.group.add(newTextMesh);
            field.inputTextMesh = newTextMesh;
        }


        /**
         * Saves or updates a notebook via the backend API.
         */
        async function saveNote() {
            if (!currentUserId) {
                showMessage("Please log in to save notes.", "error");
                return;
            }

            const title = allForms.noteEditor.titleField.currentValue;
            const content = allForms.noteEditor.contentField.currentValue;
            const notebookId = allForms.noteEditor.activeNoteId;

            if (!title) {
                showMessage("Note title cannot be empty!", "error");
                return;
            }

            try {
                const notebookData = {
                    title: title,
                    content: content,
                    userId: currentUserId // Send user ID with data
                };

                let response;
                if (notebookId) {
                    // Update existing note
                    response = await fetch(`http://localhost:3000/api/notebooks/${notebookId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json', 'X-User-Id': currentUserId },
                        body: JSON.stringify(notebookData)
                    });
                    showMessage("Notebook updated successfully!", "success");
                } else {
                    // Add new note
                    response = await fetch('http://localhost:3000/api/notebooks', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-User-Id': currentUserId },
                        body: JSON.stringify(notebookData)
                    });
                    showMessage("Notebook added successfully!", "success");
                }

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                // Clear editor fields
                allForms.noteEditor.titleField.currentValue = '';
                allForms.noteEditor.contentField.currentValue = '';
                allForms.noteEditor.activeNoteId = null;

                switchToScene('dashboard'); // Go back to dashboard
            } catch (error) {
                console.error("Error saving note:", error);
                showMessage("Failed to save notebook.", "error");
            }
        }

        /**
         * Deletes a notebook via the backend API.
         * @param {string} notebookId - The ID of the notebook to delete.
         */
        async function deleteNotebook(notebookId) {
            if (!currentUserId) {
                showMessage("Please log in to delete notes.", "error");
                return;
            }
            try {
                const response = await fetch(`http://localhost:3000/api/notebooks/${notebookId}`, {
                    method: 'DELETE',
                    headers: { 'X-User-Id': currentUserId }
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                showMessage("Notebook deleted successfully!", "success");
                fetchNotebooks(); // Re-fetch notes to update dashboard
            } catch (error) {
                console.error("Error deleting note:", error);
                showMessage("Failed to delete notebook.", "error");
            }
        }

        /**
         * The animation loop for Three.js.
         * This function is called repeatedly to render frames and update controls.
         */
        function animate() {
            requestAnimationFrame(animate); // Request the next animation frame
            controls.update(); // Update OrbitControls (for damping and auto-rotation)
            updateScaleAnimation(); // Update scale animation if active
            renderer.render(scene, camera); // Render the scene from the camera's perspective
        }

        // Start the application when the window is fully loaded
        window.onload = async function () {
            init();    // Initialize Three.js
            animate(); // Start the animation loop
        };
    </script>
</body>

</html>